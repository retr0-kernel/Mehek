// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"project/ent/brand"
	"project/ent/ingredient"
	"project/ent/inventoryitem"
	"project/ent/kitchen"
	"project/ent/kitchenresource"
	"project/ent/menu"
	"project/ent/menuitem"
	"project/ent/order"
	"project/ent/orderitem"
	"project/ent/predicate"
	"project/ent/resourceallocation"
	"project/ent/shift"
	"project/ent/staff"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBrand              = "Brand"
	TypeIngredient         = "Ingredient"
	TypeInventoryItem      = "InventoryItem"
	TypeKitchen            = "Kitchen"
	TypeKitchenResource    = "KitchenResource"
	TypeMenu               = "Menu"
	TypeMenuItem           = "MenuItem"
	TypeOrder              = "Order"
	TypeOrderItem          = "OrderItem"
	TypeResourceAllocation = "ResourceAllocation"
	TypeShift              = "Shift"
	TypeStaff              = "Staff"
)

// BrandMutation represents an operation that mutates the Brand nodes in the graph.
type BrandMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	cuisine_type   *string
	logo_url       *string
	clearedFields  map[string]struct{}
	kitchen        *int
	clearedkitchen bool
	menus          map[int]struct{}
	removedmenus   map[int]struct{}
	clearedmenus   bool
	orders         map[int]struct{}
	removedorders  map[int]struct{}
	clearedorders  bool
	done           bool
	oldValue       func(context.Context) (*Brand, error)
	predicates     []predicate.Brand
}

var _ ent.Mutation = (*BrandMutation)(nil)

// brandOption allows management of the mutation configuration using functional options.
type brandOption func(*BrandMutation)

// newBrandMutation creates new mutation for the Brand entity.
func newBrandMutation(c config, op Op, opts ...brandOption) *BrandMutation {
	m := &BrandMutation{
		config:        c,
		op:            op,
		typ:           TypeBrand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBrandID sets the ID field of the mutation.
func withBrandID(id int) brandOption {
	return func(m *BrandMutation) {
		var (
			err   error
			once  sync.Once
			value *Brand
		)
		m.oldValue = func(ctx context.Context) (*Brand, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Brand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBrand sets the old Brand of the mutation.
func withBrand(node *Brand) brandOption {
	return func(m *BrandMutation) {
		m.oldValue = func(context.Context) (*Brand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BrandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BrandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BrandMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BrandMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Brand.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BrandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BrandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BrandMutation) ResetName() {
	m.name = nil
}

// SetCuisineType sets the "cuisine_type" field.
func (m *BrandMutation) SetCuisineType(s string) {
	m.cuisine_type = &s
}

// CuisineType returns the value of the "cuisine_type" field in the mutation.
func (m *BrandMutation) CuisineType() (r string, exists bool) {
	v := m.cuisine_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCuisineType returns the old "cuisine_type" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldCuisineType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCuisineType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCuisineType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCuisineType: %w", err)
	}
	return oldValue.CuisineType, nil
}

// ResetCuisineType resets all changes to the "cuisine_type" field.
func (m *BrandMutation) ResetCuisineType() {
	m.cuisine_type = nil
}

// SetLogoURL sets the "logo_url" field.
func (m *BrandMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *BrandMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *BrandMutation) ResetLogoURL() {
	m.logo_url = nil
}

// SetKitchenID sets the "kitchen" edge to the Kitchen entity by id.
func (m *BrandMutation) SetKitchenID(id int) {
	m.kitchen = &id
}

// ClearKitchen clears the "kitchen" edge to the Kitchen entity.
func (m *BrandMutation) ClearKitchen() {
	m.clearedkitchen = true
}

// KitchenCleared reports if the "kitchen" edge to the Kitchen entity was cleared.
func (m *BrandMutation) KitchenCleared() bool {
	return m.clearedkitchen
}

// KitchenID returns the "kitchen" edge ID in the mutation.
func (m *BrandMutation) KitchenID() (id int, exists bool) {
	if m.kitchen != nil {
		return *m.kitchen, true
	}
	return
}

// KitchenIDs returns the "kitchen" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KitchenID instead. It exists only for internal usage by the builders.
func (m *BrandMutation) KitchenIDs() (ids []int) {
	if id := m.kitchen; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKitchen resets all changes to the "kitchen" edge.
func (m *BrandMutation) ResetKitchen() {
	m.kitchen = nil
	m.clearedkitchen = false
}

// AddMenuIDs adds the "menus" edge to the Menu entity by ids.
func (m *BrandMutation) AddMenuIDs(ids ...int) {
	if m.menus == nil {
		m.menus = make(map[int]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *BrandMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *BrandMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the Menu entity by IDs.
func (m *BrandMutation) RemoveMenuIDs(ids ...int) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the Menu entity.
func (m *BrandMutation) RemovedMenusIDs() (ids []int) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *BrandMutation) MenusIDs() (ids []int) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *BrandMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *BrandMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *BrandMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *BrandMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *BrandMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *BrandMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *BrandMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *BrandMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the BrandMutation builder.
func (m *BrandMutation) Where(ps ...predicate.Brand) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BrandMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BrandMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Brand, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BrandMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BrandMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Brand).
func (m *BrandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BrandMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, brand.FieldName)
	}
	if m.cuisine_type != nil {
		fields = append(fields, brand.FieldCuisineType)
	}
	if m.logo_url != nil {
		fields = append(fields, brand.FieldLogoURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BrandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case brand.FieldName:
		return m.Name()
	case brand.FieldCuisineType:
		return m.CuisineType()
	case brand.FieldLogoURL:
		return m.LogoURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BrandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case brand.FieldName:
		return m.OldName(ctx)
	case brand.FieldCuisineType:
		return m.OldCuisineType(ctx)
	case brand.FieldLogoURL:
		return m.OldLogoURL(ctx)
	}
	return nil, fmt.Errorf("unknown Brand field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case brand.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case brand.FieldCuisineType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCuisineType(v)
		return nil
	case brand.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BrandMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BrandMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Brand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BrandMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BrandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BrandMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Brand nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BrandMutation) ResetField(name string) error {
	switch name {
	case brand.FieldName:
		m.ResetName()
		return nil
	case brand.FieldCuisineType:
		m.ResetCuisineType()
		return nil
	case brand.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BrandMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.kitchen != nil {
		edges = append(edges, brand.EdgeKitchen)
	}
	if m.menus != nil {
		edges = append(edges, brand.EdgeMenus)
	}
	if m.orders != nil {
		edges = append(edges, brand.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BrandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeKitchen:
		if id := m.kitchen; id != nil {
			return []ent.Value{*id}
		}
	case brand.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case brand.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BrandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmenus != nil {
		edges = append(edges, brand.EdgeMenus)
	}
	if m.removedorders != nil {
		edges = append(edges, brand.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BrandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	case brand.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BrandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedkitchen {
		edges = append(edges, brand.EdgeKitchen)
	}
	if m.clearedmenus {
		edges = append(edges, brand.EdgeMenus)
	}
	if m.clearedorders {
		edges = append(edges, brand.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BrandMutation) EdgeCleared(name string) bool {
	switch name {
	case brand.EdgeKitchen:
		return m.clearedkitchen
	case brand.EdgeMenus:
		return m.clearedmenus
	case brand.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BrandMutation) ClearEdge(name string) error {
	switch name {
	case brand.EdgeKitchen:
		m.ClearKitchen()
		return nil
	}
	return fmt.Errorf("unknown Brand unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BrandMutation) ResetEdge(name string) error {
	switch name {
	case brand.EdgeKitchen:
		m.ResetKitchen()
		return nil
	case brand.EdgeMenus:
		m.ResetMenus()
		return nil
	case brand.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown Brand edge %s", name)
}

// IngredientMutation represents an operation that mutates the Ingredient nodes in the graph.
type IngredientMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	unit                   *string
	cost_per_unit          *float64
	addcost_per_unit       *float64
	clearedFields          map[string]struct{}
	menu_items             map[int]struct{}
	removedmenu_items      map[int]struct{}
	clearedmenu_items      bool
	inventory_items        map[int]struct{}
	removedinventory_items map[int]struct{}
	clearedinventory_items bool
	done                   bool
	oldValue               func(context.Context) (*Ingredient, error)
	predicates             []predicate.Ingredient
}

var _ ent.Mutation = (*IngredientMutation)(nil)

// ingredientOption allows management of the mutation configuration using functional options.
type ingredientOption func(*IngredientMutation)

// newIngredientMutation creates new mutation for the Ingredient entity.
func newIngredientMutation(c config, op Op, opts ...ingredientOption) *IngredientMutation {
	m := &IngredientMutation{
		config:        c,
		op:            op,
		typ:           TypeIngredient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIngredientID sets the ID field of the mutation.
func withIngredientID(id int) ingredientOption {
	return func(m *IngredientMutation) {
		var (
			err   error
			once  sync.Once
			value *Ingredient
		)
		m.oldValue = func(ctx context.Context) (*Ingredient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ingredient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIngredient sets the old Ingredient of the mutation.
func withIngredient(node *Ingredient) ingredientOption {
	return func(m *IngredientMutation) {
		m.oldValue = func(context.Context) (*Ingredient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IngredientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IngredientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IngredientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IngredientMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ingredient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *IngredientMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IngredientMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Ingredient entity.
// If the Ingredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IngredientMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IngredientMutation) ResetName() {
	m.name = nil
}

// SetUnit sets the "unit" field.
func (m *IngredientMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *IngredientMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Ingredient entity.
// If the Ingredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IngredientMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *IngredientMutation) ResetUnit() {
	m.unit = nil
}

// SetCostPerUnit sets the "cost_per_unit" field.
func (m *IngredientMutation) SetCostPerUnit(f float64) {
	m.cost_per_unit = &f
	m.addcost_per_unit = nil
}

// CostPerUnit returns the value of the "cost_per_unit" field in the mutation.
func (m *IngredientMutation) CostPerUnit() (r float64, exists bool) {
	v := m.cost_per_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldCostPerUnit returns the old "cost_per_unit" field's value of the Ingredient entity.
// If the Ingredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IngredientMutation) OldCostPerUnit(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostPerUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostPerUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostPerUnit: %w", err)
	}
	return oldValue.CostPerUnit, nil
}

// AddCostPerUnit adds f to the "cost_per_unit" field.
func (m *IngredientMutation) AddCostPerUnit(f float64) {
	if m.addcost_per_unit != nil {
		*m.addcost_per_unit += f
	} else {
		m.addcost_per_unit = &f
	}
}

// AddedCostPerUnit returns the value that was added to the "cost_per_unit" field in this mutation.
func (m *IngredientMutation) AddedCostPerUnit() (r float64, exists bool) {
	v := m.addcost_per_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetCostPerUnit resets all changes to the "cost_per_unit" field.
func (m *IngredientMutation) ResetCostPerUnit() {
	m.cost_per_unit = nil
	m.addcost_per_unit = nil
}

// AddMenuItemIDs adds the "menu_items" edge to the MenuItem entity by ids.
func (m *IngredientMutation) AddMenuItemIDs(ids ...int) {
	if m.menu_items == nil {
		m.menu_items = make(map[int]struct{})
	}
	for i := range ids {
		m.menu_items[ids[i]] = struct{}{}
	}
}

// ClearMenuItems clears the "menu_items" edge to the MenuItem entity.
func (m *IngredientMutation) ClearMenuItems() {
	m.clearedmenu_items = true
}

// MenuItemsCleared reports if the "menu_items" edge to the MenuItem entity was cleared.
func (m *IngredientMutation) MenuItemsCleared() bool {
	return m.clearedmenu_items
}

// RemoveMenuItemIDs removes the "menu_items" edge to the MenuItem entity by IDs.
func (m *IngredientMutation) RemoveMenuItemIDs(ids ...int) {
	if m.removedmenu_items == nil {
		m.removedmenu_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.menu_items, ids[i])
		m.removedmenu_items[ids[i]] = struct{}{}
	}
}

// RemovedMenuItems returns the removed IDs of the "menu_items" edge to the MenuItem entity.
func (m *IngredientMutation) RemovedMenuItemsIDs() (ids []int) {
	for id := range m.removedmenu_items {
		ids = append(ids, id)
	}
	return
}

// MenuItemsIDs returns the "menu_items" edge IDs in the mutation.
func (m *IngredientMutation) MenuItemsIDs() (ids []int) {
	for id := range m.menu_items {
		ids = append(ids, id)
	}
	return
}

// ResetMenuItems resets all changes to the "menu_items" edge.
func (m *IngredientMutation) ResetMenuItems() {
	m.menu_items = nil
	m.clearedmenu_items = false
	m.removedmenu_items = nil
}

// AddInventoryItemIDs adds the "inventory_items" edge to the InventoryItem entity by ids.
func (m *IngredientMutation) AddInventoryItemIDs(ids ...int) {
	if m.inventory_items == nil {
		m.inventory_items = make(map[int]struct{})
	}
	for i := range ids {
		m.inventory_items[ids[i]] = struct{}{}
	}
}

// ClearInventoryItems clears the "inventory_items" edge to the InventoryItem entity.
func (m *IngredientMutation) ClearInventoryItems() {
	m.clearedinventory_items = true
}

// InventoryItemsCleared reports if the "inventory_items" edge to the InventoryItem entity was cleared.
func (m *IngredientMutation) InventoryItemsCleared() bool {
	return m.clearedinventory_items
}

// RemoveInventoryItemIDs removes the "inventory_items" edge to the InventoryItem entity by IDs.
func (m *IngredientMutation) RemoveInventoryItemIDs(ids ...int) {
	if m.removedinventory_items == nil {
		m.removedinventory_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inventory_items, ids[i])
		m.removedinventory_items[ids[i]] = struct{}{}
	}
}

// RemovedInventoryItems returns the removed IDs of the "inventory_items" edge to the InventoryItem entity.
func (m *IngredientMutation) RemovedInventoryItemsIDs() (ids []int) {
	for id := range m.removedinventory_items {
		ids = append(ids, id)
	}
	return
}

// InventoryItemsIDs returns the "inventory_items" edge IDs in the mutation.
func (m *IngredientMutation) InventoryItemsIDs() (ids []int) {
	for id := range m.inventory_items {
		ids = append(ids, id)
	}
	return
}

// ResetInventoryItems resets all changes to the "inventory_items" edge.
func (m *IngredientMutation) ResetInventoryItems() {
	m.inventory_items = nil
	m.clearedinventory_items = false
	m.removedinventory_items = nil
}

// Where appends a list predicates to the IngredientMutation builder.
func (m *IngredientMutation) Where(ps ...predicate.Ingredient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IngredientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IngredientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ingredient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IngredientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IngredientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ingredient).
func (m *IngredientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IngredientMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, ingredient.FieldName)
	}
	if m.unit != nil {
		fields = append(fields, ingredient.FieldUnit)
	}
	if m.cost_per_unit != nil {
		fields = append(fields, ingredient.FieldCostPerUnit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IngredientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ingredient.FieldName:
		return m.Name()
	case ingredient.FieldUnit:
		return m.Unit()
	case ingredient.FieldCostPerUnit:
		return m.CostPerUnit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IngredientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ingredient.FieldName:
		return m.OldName(ctx)
	case ingredient.FieldUnit:
		return m.OldUnit(ctx)
	case ingredient.FieldCostPerUnit:
		return m.OldCostPerUnit(ctx)
	}
	return nil, fmt.Errorf("unknown Ingredient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IngredientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ingredient.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ingredient.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case ingredient.FieldCostPerUnit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostPerUnit(v)
		return nil
	}
	return fmt.Errorf("unknown Ingredient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IngredientMutation) AddedFields() []string {
	var fields []string
	if m.addcost_per_unit != nil {
		fields = append(fields, ingredient.FieldCostPerUnit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IngredientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ingredient.FieldCostPerUnit:
		return m.AddedCostPerUnit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IngredientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ingredient.FieldCostPerUnit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCostPerUnit(v)
		return nil
	}
	return fmt.Errorf("unknown Ingredient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IngredientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IngredientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IngredientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ingredient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IngredientMutation) ResetField(name string) error {
	switch name {
	case ingredient.FieldName:
		m.ResetName()
		return nil
	case ingredient.FieldUnit:
		m.ResetUnit()
		return nil
	case ingredient.FieldCostPerUnit:
		m.ResetCostPerUnit()
		return nil
	}
	return fmt.Errorf("unknown Ingredient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IngredientMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.menu_items != nil {
		edges = append(edges, ingredient.EdgeMenuItems)
	}
	if m.inventory_items != nil {
		edges = append(edges, ingredient.EdgeInventoryItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IngredientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ingredient.EdgeMenuItems:
		ids := make([]ent.Value, 0, len(m.menu_items))
		for id := range m.menu_items {
			ids = append(ids, id)
		}
		return ids
	case ingredient.EdgeInventoryItems:
		ids := make([]ent.Value, 0, len(m.inventory_items))
		for id := range m.inventory_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IngredientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmenu_items != nil {
		edges = append(edges, ingredient.EdgeMenuItems)
	}
	if m.removedinventory_items != nil {
		edges = append(edges, ingredient.EdgeInventoryItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IngredientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ingredient.EdgeMenuItems:
		ids := make([]ent.Value, 0, len(m.removedmenu_items))
		for id := range m.removedmenu_items {
			ids = append(ids, id)
		}
		return ids
	case ingredient.EdgeInventoryItems:
		ids := make([]ent.Value, 0, len(m.removedinventory_items))
		for id := range m.removedinventory_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IngredientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmenu_items {
		edges = append(edges, ingredient.EdgeMenuItems)
	}
	if m.clearedinventory_items {
		edges = append(edges, ingredient.EdgeInventoryItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IngredientMutation) EdgeCleared(name string) bool {
	switch name {
	case ingredient.EdgeMenuItems:
		return m.clearedmenu_items
	case ingredient.EdgeInventoryItems:
		return m.clearedinventory_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IngredientMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Ingredient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IngredientMutation) ResetEdge(name string) error {
	switch name {
	case ingredient.EdgeMenuItems:
		m.ResetMenuItems()
		return nil
	case ingredient.EdgeInventoryItems:
		m.ResetInventoryItems()
		return nil
	}
	return fmt.Errorf("unknown Ingredient edge %s", name)
}

// InventoryItemMutation represents an operation that mutates the InventoryItem nodes in the graph.
type InventoryItemMutation struct {
	config
	op                Op
	typ               string
	id                *int
	quantity          *float64
	addquantity       *float64
	expiration_date   *time.Time
	clearedFields     map[string]struct{}
	kitchen           *int
	clearedkitchen    bool
	ingredient        *int
	clearedingredient bool
	done              bool
	oldValue          func(context.Context) (*InventoryItem, error)
	predicates        []predicate.InventoryItem
}

var _ ent.Mutation = (*InventoryItemMutation)(nil)

// inventoryitemOption allows management of the mutation configuration using functional options.
type inventoryitemOption func(*InventoryItemMutation)

// newInventoryItemMutation creates new mutation for the InventoryItem entity.
func newInventoryItemMutation(c config, op Op, opts ...inventoryitemOption) *InventoryItemMutation {
	m := &InventoryItemMutation{
		config:        c,
		op:            op,
		typ:           TypeInventoryItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryItemID sets the ID field of the mutation.
func withInventoryItemID(id int) inventoryitemOption {
	return func(m *InventoryItemMutation) {
		var (
			err   error
			once  sync.Once
			value *InventoryItem
		)
		m.oldValue = func(ctx context.Context) (*InventoryItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InventoryItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventoryItem sets the old InventoryItem of the mutation.
func withInventoryItem(node *InventoryItem) inventoryitemOption {
	return func(m *InventoryItemMutation) {
		m.oldValue = func(context.Context) (*InventoryItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InventoryItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InventoryItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *InventoryItemMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *InventoryItemMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the InventoryItem entity.
// If the InventoryItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *InventoryItemMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *InventoryItemMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *InventoryItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetExpirationDate sets the "expiration_date" field.
func (m *InventoryItemMutation) SetExpirationDate(t time.Time) {
	m.expiration_date = &t
}

// ExpirationDate returns the value of the "expiration_date" field in the mutation.
func (m *InventoryItemMutation) ExpirationDate() (r time.Time, exists bool) {
	v := m.expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationDate returns the old "expiration_date" field's value of the InventoryItem entity.
// If the InventoryItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemMutation) OldExpirationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationDate: %w", err)
	}
	return oldValue.ExpirationDate, nil
}

// ClearExpirationDate clears the value of the "expiration_date" field.
func (m *InventoryItemMutation) ClearExpirationDate() {
	m.expiration_date = nil
	m.clearedFields[inventoryitem.FieldExpirationDate] = struct{}{}
}

// ExpirationDateCleared returns if the "expiration_date" field was cleared in this mutation.
func (m *InventoryItemMutation) ExpirationDateCleared() bool {
	_, ok := m.clearedFields[inventoryitem.FieldExpirationDate]
	return ok
}

// ResetExpirationDate resets all changes to the "expiration_date" field.
func (m *InventoryItemMutation) ResetExpirationDate() {
	m.expiration_date = nil
	delete(m.clearedFields, inventoryitem.FieldExpirationDate)
}

// SetKitchenID sets the "kitchen" edge to the Kitchen entity by id.
func (m *InventoryItemMutation) SetKitchenID(id int) {
	m.kitchen = &id
}

// ClearKitchen clears the "kitchen" edge to the Kitchen entity.
func (m *InventoryItemMutation) ClearKitchen() {
	m.clearedkitchen = true
}

// KitchenCleared reports if the "kitchen" edge to the Kitchen entity was cleared.
func (m *InventoryItemMutation) KitchenCleared() bool {
	return m.clearedkitchen
}

// KitchenID returns the "kitchen" edge ID in the mutation.
func (m *InventoryItemMutation) KitchenID() (id int, exists bool) {
	if m.kitchen != nil {
		return *m.kitchen, true
	}
	return
}

// KitchenIDs returns the "kitchen" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KitchenID instead. It exists only for internal usage by the builders.
func (m *InventoryItemMutation) KitchenIDs() (ids []int) {
	if id := m.kitchen; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKitchen resets all changes to the "kitchen" edge.
func (m *InventoryItemMutation) ResetKitchen() {
	m.kitchen = nil
	m.clearedkitchen = false
}

// SetIngredientID sets the "ingredient" edge to the Ingredient entity by id.
func (m *InventoryItemMutation) SetIngredientID(id int) {
	m.ingredient = &id
}

// ClearIngredient clears the "ingredient" edge to the Ingredient entity.
func (m *InventoryItemMutation) ClearIngredient() {
	m.clearedingredient = true
}

// IngredientCleared reports if the "ingredient" edge to the Ingredient entity was cleared.
func (m *InventoryItemMutation) IngredientCleared() bool {
	return m.clearedingredient
}

// IngredientID returns the "ingredient" edge ID in the mutation.
func (m *InventoryItemMutation) IngredientID() (id int, exists bool) {
	if m.ingredient != nil {
		return *m.ingredient, true
	}
	return
}

// IngredientIDs returns the "ingredient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IngredientID instead. It exists only for internal usage by the builders.
func (m *InventoryItemMutation) IngredientIDs() (ids []int) {
	if id := m.ingredient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIngredient resets all changes to the "ingredient" edge.
func (m *InventoryItemMutation) ResetIngredient() {
	m.ingredient = nil
	m.clearedingredient = false
}

// Where appends a list predicates to the InventoryItemMutation builder.
func (m *InventoryItemMutation) Where(ps ...predicate.InventoryItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InventoryItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InventoryItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InventoryItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InventoryItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InventoryItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InventoryItem).
func (m *InventoryItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryItemMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.quantity != nil {
		fields = append(fields, inventoryitem.FieldQuantity)
	}
	if m.expiration_date != nil {
		fields = append(fields, inventoryitem.FieldExpirationDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventoryitem.FieldQuantity:
		return m.Quantity()
	case inventoryitem.FieldExpirationDate:
		return m.ExpirationDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventoryitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case inventoryitem.FieldExpirationDate:
		return m.OldExpirationDate(ctx)
	}
	return nil, fmt.Errorf("unknown InventoryItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventoryitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case inventoryitem.FieldExpirationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationDate(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryItemMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, inventoryitem.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inventoryitem.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inventoryitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inventoryitem.FieldExpirationDate) {
		fields = append(fields, inventoryitem.FieldExpirationDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryItemMutation) ClearField(name string) error {
	switch name {
	case inventoryitem.FieldExpirationDate:
		m.ClearExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown InventoryItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryItemMutation) ResetField(name string) error {
	switch name {
	case inventoryitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case inventoryitem.FieldExpirationDate:
		m.ResetExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown InventoryItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.kitchen != nil {
		edges = append(edges, inventoryitem.EdgeKitchen)
	}
	if m.ingredient != nil {
		edges = append(edges, inventoryitem.EdgeIngredient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inventoryitem.EdgeKitchen:
		if id := m.kitchen; id != nil {
			return []ent.Value{*id}
		}
	case inventoryitem.EdgeIngredient:
		if id := m.ingredient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedkitchen {
		edges = append(edges, inventoryitem.EdgeKitchen)
	}
	if m.clearedingredient {
		edges = append(edges, inventoryitem.EdgeIngredient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryItemMutation) EdgeCleared(name string) bool {
	switch name {
	case inventoryitem.EdgeKitchen:
		return m.clearedkitchen
	case inventoryitem.EdgeIngredient:
		return m.clearedingredient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryItemMutation) ClearEdge(name string) error {
	switch name {
	case inventoryitem.EdgeKitchen:
		m.ClearKitchen()
		return nil
	case inventoryitem.EdgeIngredient:
		m.ClearIngredient()
		return nil
	}
	return fmt.Errorf("unknown InventoryItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryItemMutation) ResetEdge(name string) error {
	switch name {
	case inventoryitem.EdgeKitchen:
		m.ResetKitchen()
		return nil
	case inventoryitem.EdgeIngredient:
		m.ResetIngredient()
		return nil
	}
	return fmt.Errorf("unknown InventoryItem edge %s", name)
}

// KitchenMutation represents an operation that mutates the Kitchen nodes in the graph.
type KitchenMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	location         *string
	capacity         *int
	addcapacity      *int
	operating_hours  *map[string][]string
	clearedFields    map[string]struct{}
	resources        map[int]struct{}
	removedresources map[int]struct{}
	clearedresources bool
	staff            map[int]struct{}
	removedstaff     map[int]struct{}
	clearedstaff     bool
	brands           map[int]struct{}
	removedbrands    map[int]struct{}
	clearedbrands    bool
	inventory        map[int]struct{}
	removedinventory map[int]struct{}
	clearedinventory bool
	done             bool
	oldValue         func(context.Context) (*Kitchen, error)
	predicates       []predicate.Kitchen
}

var _ ent.Mutation = (*KitchenMutation)(nil)

// kitchenOption allows management of the mutation configuration using functional options.
type kitchenOption func(*KitchenMutation)

// newKitchenMutation creates new mutation for the Kitchen entity.
func newKitchenMutation(c config, op Op, opts ...kitchenOption) *KitchenMutation {
	m := &KitchenMutation{
		config:        c,
		op:            op,
		typ:           TypeKitchen,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKitchenID sets the ID field of the mutation.
func withKitchenID(id int) kitchenOption {
	return func(m *KitchenMutation) {
		var (
			err   error
			once  sync.Once
			value *Kitchen
		)
		m.oldValue = func(ctx context.Context) (*Kitchen, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Kitchen.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKitchen sets the old Kitchen of the mutation.
func withKitchen(node *Kitchen) kitchenOption {
	return func(m *KitchenMutation) {
		m.oldValue = func(context.Context) (*Kitchen, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KitchenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KitchenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KitchenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KitchenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Kitchen.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *KitchenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *KitchenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Kitchen entity.
// If the Kitchen object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KitchenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *KitchenMutation) ResetName() {
	m.name = nil
}

// SetLocation sets the "location" field.
func (m *KitchenMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *KitchenMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Kitchen entity.
// If the Kitchen object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KitchenMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *KitchenMutation) ResetLocation() {
	m.location = nil
}

// SetCapacity sets the "capacity" field.
func (m *KitchenMutation) SetCapacity(i int) {
	m.capacity = &i
	m.addcapacity = nil
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *KitchenMutation) Capacity() (r int, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the Kitchen entity.
// If the Kitchen object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KitchenMutation) OldCapacity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds i to the "capacity" field.
func (m *KitchenMutation) AddCapacity(i int) {
	if m.addcapacity != nil {
		*m.addcapacity += i
	} else {
		m.addcapacity = &i
	}
}

// AddedCapacity returns the value that was added to the "capacity" field in this mutation.
func (m *KitchenMutation) AddedCapacity() (r int, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *KitchenMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
}

// SetOperatingHours sets the "operating_hours" field.
func (m *KitchenMutation) SetOperatingHours(value map[string][]string) {
	m.operating_hours = &value
}

// OperatingHours returns the value of the "operating_hours" field in the mutation.
func (m *KitchenMutation) OperatingHours() (r map[string][]string, exists bool) {
	v := m.operating_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatingHours returns the old "operating_hours" field's value of the Kitchen entity.
// If the Kitchen object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KitchenMutation) OldOperatingHours(ctx context.Context) (v map[string][]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatingHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatingHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatingHours: %w", err)
	}
	return oldValue.OperatingHours, nil
}

// ResetOperatingHours resets all changes to the "operating_hours" field.
func (m *KitchenMutation) ResetOperatingHours() {
	m.operating_hours = nil
}

// AddResourceIDs adds the "resources" edge to the KitchenResource entity by ids.
func (m *KitchenMutation) AddResourceIDs(ids ...int) {
	if m.resources == nil {
		m.resources = make(map[int]struct{})
	}
	for i := range ids {
		m.resources[ids[i]] = struct{}{}
	}
}

// ClearResources clears the "resources" edge to the KitchenResource entity.
func (m *KitchenMutation) ClearResources() {
	m.clearedresources = true
}

// ResourcesCleared reports if the "resources" edge to the KitchenResource entity was cleared.
func (m *KitchenMutation) ResourcesCleared() bool {
	return m.clearedresources
}

// RemoveResourceIDs removes the "resources" edge to the KitchenResource entity by IDs.
func (m *KitchenMutation) RemoveResourceIDs(ids ...int) {
	if m.removedresources == nil {
		m.removedresources = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resources, ids[i])
		m.removedresources[ids[i]] = struct{}{}
	}
}

// RemovedResources returns the removed IDs of the "resources" edge to the KitchenResource entity.
func (m *KitchenMutation) RemovedResourcesIDs() (ids []int) {
	for id := range m.removedresources {
		ids = append(ids, id)
	}
	return
}

// ResourcesIDs returns the "resources" edge IDs in the mutation.
func (m *KitchenMutation) ResourcesIDs() (ids []int) {
	for id := range m.resources {
		ids = append(ids, id)
	}
	return
}

// ResetResources resets all changes to the "resources" edge.
func (m *KitchenMutation) ResetResources() {
	m.resources = nil
	m.clearedresources = false
	m.removedresources = nil
}

// AddStaffIDs adds the "staff" edge to the Staff entity by ids.
func (m *KitchenMutation) AddStaffIDs(ids ...int) {
	if m.staff == nil {
		m.staff = make(map[int]struct{})
	}
	for i := range ids {
		m.staff[ids[i]] = struct{}{}
	}
}

// ClearStaff clears the "staff" edge to the Staff entity.
func (m *KitchenMutation) ClearStaff() {
	m.clearedstaff = true
}

// StaffCleared reports if the "staff" edge to the Staff entity was cleared.
func (m *KitchenMutation) StaffCleared() bool {
	return m.clearedstaff
}

// RemoveStaffIDs removes the "staff" edge to the Staff entity by IDs.
func (m *KitchenMutation) RemoveStaffIDs(ids ...int) {
	if m.removedstaff == nil {
		m.removedstaff = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.staff, ids[i])
		m.removedstaff[ids[i]] = struct{}{}
	}
}

// RemovedStaff returns the removed IDs of the "staff" edge to the Staff entity.
func (m *KitchenMutation) RemovedStaffIDs() (ids []int) {
	for id := range m.removedstaff {
		ids = append(ids, id)
	}
	return
}

// StaffIDs returns the "staff" edge IDs in the mutation.
func (m *KitchenMutation) StaffIDs() (ids []int) {
	for id := range m.staff {
		ids = append(ids, id)
	}
	return
}

// ResetStaff resets all changes to the "staff" edge.
func (m *KitchenMutation) ResetStaff() {
	m.staff = nil
	m.clearedstaff = false
	m.removedstaff = nil
}

// AddBrandIDs adds the "brands" edge to the Brand entity by ids.
func (m *KitchenMutation) AddBrandIDs(ids ...int) {
	if m.brands == nil {
		m.brands = make(map[int]struct{})
	}
	for i := range ids {
		m.brands[ids[i]] = struct{}{}
	}
}

// ClearBrands clears the "brands" edge to the Brand entity.
func (m *KitchenMutation) ClearBrands() {
	m.clearedbrands = true
}

// BrandsCleared reports if the "brands" edge to the Brand entity was cleared.
func (m *KitchenMutation) BrandsCleared() bool {
	return m.clearedbrands
}

// RemoveBrandIDs removes the "brands" edge to the Brand entity by IDs.
func (m *KitchenMutation) RemoveBrandIDs(ids ...int) {
	if m.removedbrands == nil {
		m.removedbrands = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.brands, ids[i])
		m.removedbrands[ids[i]] = struct{}{}
	}
}

// RemovedBrands returns the removed IDs of the "brands" edge to the Brand entity.
func (m *KitchenMutation) RemovedBrandsIDs() (ids []int) {
	for id := range m.removedbrands {
		ids = append(ids, id)
	}
	return
}

// BrandsIDs returns the "brands" edge IDs in the mutation.
func (m *KitchenMutation) BrandsIDs() (ids []int) {
	for id := range m.brands {
		ids = append(ids, id)
	}
	return
}

// ResetBrands resets all changes to the "brands" edge.
func (m *KitchenMutation) ResetBrands() {
	m.brands = nil
	m.clearedbrands = false
	m.removedbrands = nil
}

// AddInventoryIDs adds the "inventory" edge to the InventoryItem entity by ids.
func (m *KitchenMutation) AddInventoryIDs(ids ...int) {
	if m.inventory == nil {
		m.inventory = make(map[int]struct{})
	}
	for i := range ids {
		m.inventory[ids[i]] = struct{}{}
	}
}

// ClearInventory clears the "inventory" edge to the InventoryItem entity.
func (m *KitchenMutation) ClearInventory() {
	m.clearedinventory = true
}

// InventoryCleared reports if the "inventory" edge to the InventoryItem entity was cleared.
func (m *KitchenMutation) InventoryCleared() bool {
	return m.clearedinventory
}

// RemoveInventoryIDs removes the "inventory" edge to the InventoryItem entity by IDs.
func (m *KitchenMutation) RemoveInventoryIDs(ids ...int) {
	if m.removedinventory == nil {
		m.removedinventory = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inventory, ids[i])
		m.removedinventory[ids[i]] = struct{}{}
	}
}

// RemovedInventory returns the removed IDs of the "inventory" edge to the InventoryItem entity.
func (m *KitchenMutation) RemovedInventoryIDs() (ids []int) {
	for id := range m.removedinventory {
		ids = append(ids, id)
	}
	return
}

// InventoryIDs returns the "inventory" edge IDs in the mutation.
func (m *KitchenMutation) InventoryIDs() (ids []int) {
	for id := range m.inventory {
		ids = append(ids, id)
	}
	return
}

// ResetInventory resets all changes to the "inventory" edge.
func (m *KitchenMutation) ResetInventory() {
	m.inventory = nil
	m.clearedinventory = false
	m.removedinventory = nil
}

// Where appends a list predicates to the KitchenMutation builder.
func (m *KitchenMutation) Where(ps ...predicate.Kitchen) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KitchenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KitchenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Kitchen, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KitchenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KitchenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Kitchen).
func (m *KitchenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KitchenMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, kitchen.FieldName)
	}
	if m.location != nil {
		fields = append(fields, kitchen.FieldLocation)
	}
	if m.capacity != nil {
		fields = append(fields, kitchen.FieldCapacity)
	}
	if m.operating_hours != nil {
		fields = append(fields, kitchen.FieldOperatingHours)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KitchenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kitchen.FieldName:
		return m.Name()
	case kitchen.FieldLocation:
		return m.Location()
	case kitchen.FieldCapacity:
		return m.Capacity()
	case kitchen.FieldOperatingHours:
		return m.OperatingHours()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KitchenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kitchen.FieldName:
		return m.OldName(ctx)
	case kitchen.FieldLocation:
		return m.OldLocation(ctx)
	case kitchen.FieldCapacity:
		return m.OldCapacity(ctx)
	case kitchen.FieldOperatingHours:
		return m.OldOperatingHours(ctx)
	}
	return nil, fmt.Errorf("unknown Kitchen field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KitchenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kitchen.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case kitchen.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case kitchen.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	case kitchen.FieldOperatingHours:
		v, ok := value.(map[string][]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatingHours(v)
		return nil
	}
	return fmt.Errorf("unknown Kitchen field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KitchenMutation) AddedFields() []string {
	var fields []string
	if m.addcapacity != nil {
		fields = append(fields, kitchen.FieldCapacity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KitchenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kitchen.FieldCapacity:
		return m.AddedCapacity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KitchenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kitchen.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown Kitchen numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KitchenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KitchenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KitchenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Kitchen nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KitchenMutation) ResetField(name string) error {
	switch name {
	case kitchen.FieldName:
		m.ResetName()
		return nil
	case kitchen.FieldLocation:
		m.ResetLocation()
		return nil
	case kitchen.FieldCapacity:
		m.ResetCapacity()
		return nil
	case kitchen.FieldOperatingHours:
		m.ResetOperatingHours()
		return nil
	}
	return fmt.Errorf("unknown Kitchen field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KitchenMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.resources != nil {
		edges = append(edges, kitchen.EdgeResources)
	}
	if m.staff != nil {
		edges = append(edges, kitchen.EdgeStaff)
	}
	if m.brands != nil {
		edges = append(edges, kitchen.EdgeBrands)
	}
	if m.inventory != nil {
		edges = append(edges, kitchen.EdgeInventory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KitchenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kitchen.EdgeResources:
		ids := make([]ent.Value, 0, len(m.resources))
		for id := range m.resources {
			ids = append(ids, id)
		}
		return ids
	case kitchen.EdgeStaff:
		ids := make([]ent.Value, 0, len(m.staff))
		for id := range m.staff {
			ids = append(ids, id)
		}
		return ids
	case kitchen.EdgeBrands:
		ids := make([]ent.Value, 0, len(m.brands))
		for id := range m.brands {
			ids = append(ids, id)
		}
		return ids
	case kitchen.EdgeInventory:
		ids := make([]ent.Value, 0, len(m.inventory))
		for id := range m.inventory {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KitchenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedresources != nil {
		edges = append(edges, kitchen.EdgeResources)
	}
	if m.removedstaff != nil {
		edges = append(edges, kitchen.EdgeStaff)
	}
	if m.removedbrands != nil {
		edges = append(edges, kitchen.EdgeBrands)
	}
	if m.removedinventory != nil {
		edges = append(edges, kitchen.EdgeInventory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KitchenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kitchen.EdgeResources:
		ids := make([]ent.Value, 0, len(m.removedresources))
		for id := range m.removedresources {
			ids = append(ids, id)
		}
		return ids
	case kitchen.EdgeStaff:
		ids := make([]ent.Value, 0, len(m.removedstaff))
		for id := range m.removedstaff {
			ids = append(ids, id)
		}
		return ids
	case kitchen.EdgeBrands:
		ids := make([]ent.Value, 0, len(m.removedbrands))
		for id := range m.removedbrands {
			ids = append(ids, id)
		}
		return ids
	case kitchen.EdgeInventory:
		ids := make([]ent.Value, 0, len(m.removedinventory))
		for id := range m.removedinventory {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KitchenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedresources {
		edges = append(edges, kitchen.EdgeResources)
	}
	if m.clearedstaff {
		edges = append(edges, kitchen.EdgeStaff)
	}
	if m.clearedbrands {
		edges = append(edges, kitchen.EdgeBrands)
	}
	if m.clearedinventory {
		edges = append(edges, kitchen.EdgeInventory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KitchenMutation) EdgeCleared(name string) bool {
	switch name {
	case kitchen.EdgeResources:
		return m.clearedresources
	case kitchen.EdgeStaff:
		return m.clearedstaff
	case kitchen.EdgeBrands:
		return m.clearedbrands
	case kitchen.EdgeInventory:
		return m.clearedinventory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KitchenMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Kitchen unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KitchenMutation) ResetEdge(name string) error {
	switch name {
	case kitchen.EdgeResources:
		m.ResetResources()
		return nil
	case kitchen.EdgeStaff:
		m.ResetStaff()
		return nil
	case kitchen.EdgeBrands:
		m.ResetBrands()
		return nil
	case kitchen.EdgeInventory:
		m.ResetInventory()
		return nil
	}
	return fmt.Errorf("unknown Kitchen edge %s", name)
}

// KitchenResourceMutation represents an operation that mutates the KitchenResource nodes in the graph.
type KitchenResourceMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	_type              *string
	capacity           *int
	addcapacity        *int
	available          *bool
	clearedFields      map[string]struct{}
	kitchen            *int
	clearedkitchen     bool
	allocations        map[int]struct{}
	removedallocations map[int]struct{}
	clearedallocations bool
	done               bool
	oldValue           func(context.Context) (*KitchenResource, error)
	predicates         []predicate.KitchenResource
}

var _ ent.Mutation = (*KitchenResourceMutation)(nil)

// kitchenresourceOption allows management of the mutation configuration using functional options.
type kitchenresourceOption func(*KitchenResourceMutation)

// newKitchenResourceMutation creates new mutation for the KitchenResource entity.
func newKitchenResourceMutation(c config, op Op, opts ...kitchenresourceOption) *KitchenResourceMutation {
	m := &KitchenResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeKitchenResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKitchenResourceID sets the ID field of the mutation.
func withKitchenResourceID(id int) kitchenresourceOption {
	return func(m *KitchenResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *KitchenResource
		)
		m.oldValue = func(ctx context.Context) (*KitchenResource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KitchenResource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKitchenResource sets the old KitchenResource of the mutation.
func withKitchenResource(node *KitchenResource) kitchenresourceOption {
	return func(m *KitchenResourceMutation) {
		m.oldValue = func(context.Context) (*KitchenResource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KitchenResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KitchenResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KitchenResourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KitchenResourceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KitchenResource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *KitchenResourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *KitchenResourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the KitchenResource entity.
// If the KitchenResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KitchenResourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *KitchenResourceMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *KitchenResourceMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *KitchenResourceMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the KitchenResource entity.
// If the KitchenResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KitchenResourceMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *KitchenResourceMutation) ResetType() {
	m._type = nil
}

// SetCapacity sets the "capacity" field.
func (m *KitchenResourceMutation) SetCapacity(i int) {
	m.capacity = &i
	m.addcapacity = nil
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *KitchenResourceMutation) Capacity() (r int, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the KitchenResource entity.
// If the KitchenResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KitchenResourceMutation) OldCapacity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds i to the "capacity" field.
func (m *KitchenResourceMutation) AddCapacity(i int) {
	if m.addcapacity != nil {
		*m.addcapacity += i
	} else {
		m.addcapacity = &i
	}
}

// AddedCapacity returns the value that was added to the "capacity" field in this mutation.
func (m *KitchenResourceMutation) AddedCapacity() (r int, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *KitchenResourceMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
}

// SetAvailable sets the "available" field.
func (m *KitchenResourceMutation) SetAvailable(b bool) {
	m.available = &b
}

// Available returns the value of the "available" field in the mutation.
func (m *KitchenResourceMutation) Available() (r bool, exists bool) {
	v := m.available
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailable returns the old "available" field's value of the KitchenResource entity.
// If the KitchenResource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KitchenResourceMutation) OldAvailable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailable: %w", err)
	}
	return oldValue.Available, nil
}

// ResetAvailable resets all changes to the "available" field.
func (m *KitchenResourceMutation) ResetAvailable() {
	m.available = nil
}

// SetKitchenID sets the "kitchen" edge to the Kitchen entity by id.
func (m *KitchenResourceMutation) SetKitchenID(id int) {
	m.kitchen = &id
}

// ClearKitchen clears the "kitchen" edge to the Kitchen entity.
func (m *KitchenResourceMutation) ClearKitchen() {
	m.clearedkitchen = true
}

// KitchenCleared reports if the "kitchen" edge to the Kitchen entity was cleared.
func (m *KitchenResourceMutation) KitchenCleared() bool {
	return m.clearedkitchen
}

// KitchenID returns the "kitchen" edge ID in the mutation.
func (m *KitchenResourceMutation) KitchenID() (id int, exists bool) {
	if m.kitchen != nil {
		return *m.kitchen, true
	}
	return
}

// KitchenIDs returns the "kitchen" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KitchenID instead. It exists only for internal usage by the builders.
func (m *KitchenResourceMutation) KitchenIDs() (ids []int) {
	if id := m.kitchen; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKitchen resets all changes to the "kitchen" edge.
func (m *KitchenResourceMutation) ResetKitchen() {
	m.kitchen = nil
	m.clearedkitchen = false
}

// AddAllocationIDs adds the "allocations" edge to the ResourceAllocation entity by ids.
func (m *KitchenResourceMutation) AddAllocationIDs(ids ...int) {
	if m.allocations == nil {
		m.allocations = make(map[int]struct{})
	}
	for i := range ids {
		m.allocations[ids[i]] = struct{}{}
	}
}

// ClearAllocations clears the "allocations" edge to the ResourceAllocation entity.
func (m *KitchenResourceMutation) ClearAllocations() {
	m.clearedallocations = true
}

// AllocationsCleared reports if the "allocations" edge to the ResourceAllocation entity was cleared.
func (m *KitchenResourceMutation) AllocationsCleared() bool {
	return m.clearedallocations
}

// RemoveAllocationIDs removes the "allocations" edge to the ResourceAllocation entity by IDs.
func (m *KitchenResourceMutation) RemoveAllocationIDs(ids ...int) {
	if m.removedallocations == nil {
		m.removedallocations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.allocations, ids[i])
		m.removedallocations[ids[i]] = struct{}{}
	}
}

// RemovedAllocations returns the removed IDs of the "allocations" edge to the ResourceAllocation entity.
func (m *KitchenResourceMutation) RemovedAllocationsIDs() (ids []int) {
	for id := range m.removedallocations {
		ids = append(ids, id)
	}
	return
}

// AllocationsIDs returns the "allocations" edge IDs in the mutation.
func (m *KitchenResourceMutation) AllocationsIDs() (ids []int) {
	for id := range m.allocations {
		ids = append(ids, id)
	}
	return
}

// ResetAllocations resets all changes to the "allocations" edge.
func (m *KitchenResourceMutation) ResetAllocations() {
	m.allocations = nil
	m.clearedallocations = false
	m.removedallocations = nil
}

// Where appends a list predicates to the KitchenResourceMutation builder.
func (m *KitchenResourceMutation) Where(ps ...predicate.KitchenResource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KitchenResourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KitchenResourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.KitchenResource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KitchenResourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KitchenResourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (KitchenResource).
func (m *KitchenResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KitchenResourceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, kitchenresource.FieldName)
	}
	if m._type != nil {
		fields = append(fields, kitchenresource.FieldType)
	}
	if m.capacity != nil {
		fields = append(fields, kitchenresource.FieldCapacity)
	}
	if m.available != nil {
		fields = append(fields, kitchenresource.FieldAvailable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KitchenResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kitchenresource.FieldName:
		return m.Name()
	case kitchenresource.FieldType:
		return m.GetType()
	case kitchenresource.FieldCapacity:
		return m.Capacity()
	case kitchenresource.FieldAvailable:
		return m.Available()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KitchenResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kitchenresource.FieldName:
		return m.OldName(ctx)
	case kitchenresource.FieldType:
		return m.OldType(ctx)
	case kitchenresource.FieldCapacity:
		return m.OldCapacity(ctx)
	case kitchenresource.FieldAvailable:
		return m.OldAvailable(ctx)
	}
	return nil, fmt.Errorf("unknown KitchenResource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KitchenResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kitchenresource.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case kitchenresource.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case kitchenresource.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	case kitchenresource.FieldAvailable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailable(v)
		return nil
	}
	return fmt.Errorf("unknown KitchenResource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KitchenResourceMutation) AddedFields() []string {
	var fields []string
	if m.addcapacity != nil {
		fields = append(fields, kitchenresource.FieldCapacity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KitchenResourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kitchenresource.FieldCapacity:
		return m.AddedCapacity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KitchenResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kitchenresource.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown KitchenResource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KitchenResourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KitchenResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KitchenResourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KitchenResource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KitchenResourceMutation) ResetField(name string) error {
	switch name {
	case kitchenresource.FieldName:
		m.ResetName()
		return nil
	case kitchenresource.FieldType:
		m.ResetType()
		return nil
	case kitchenresource.FieldCapacity:
		m.ResetCapacity()
		return nil
	case kitchenresource.FieldAvailable:
		m.ResetAvailable()
		return nil
	}
	return fmt.Errorf("unknown KitchenResource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KitchenResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.kitchen != nil {
		edges = append(edges, kitchenresource.EdgeKitchen)
	}
	if m.allocations != nil {
		edges = append(edges, kitchenresource.EdgeAllocations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KitchenResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kitchenresource.EdgeKitchen:
		if id := m.kitchen; id != nil {
			return []ent.Value{*id}
		}
	case kitchenresource.EdgeAllocations:
		ids := make([]ent.Value, 0, len(m.allocations))
		for id := range m.allocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KitchenResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedallocations != nil {
		edges = append(edges, kitchenresource.EdgeAllocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KitchenResourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kitchenresource.EdgeAllocations:
		ids := make([]ent.Value, 0, len(m.removedallocations))
		for id := range m.removedallocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KitchenResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedkitchen {
		edges = append(edges, kitchenresource.EdgeKitchen)
	}
	if m.clearedallocations {
		edges = append(edges, kitchenresource.EdgeAllocations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KitchenResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case kitchenresource.EdgeKitchen:
		return m.clearedkitchen
	case kitchenresource.EdgeAllocations:
		return m.clearedallocations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KitchenResourceMutation) ClearEdge(name string) error {
	switch name {
	case kitchenresource.EdgeKitchen:
		m.ClearKitchen()
		return nil
	}
	return fmt.Errorf("unknown KitchenResource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KitchenResourceMutation) ResetEdge(name string) error {
	switch name {
	case kitchenresource.EdgeKitchen:
		m.ResetKitchen()
		return nil
	case kitchenresource.EdgeAllocations:
		m.ResetAllocations()
		return nil
	}
	return fmt.Errorf("unknown KitchenResource edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	active        *bool
	clearedFields map[string]struct{}
	brand         *int
	clearedbrand  bool
	items         map[int]struct{}
	removeditems  map[int]struct{}
	cleareditems  bool
	done          bool
	oldValue      func(context.Context) (*Menu, error)
	predicates    []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id int) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
}

// SetActive sets the "active" field.
func (m *MenuMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *MenuMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *MenuMutation) ResetActive() {
	m.active = nil
}

// SetBrandID sets the "brand" edge to the Brand entity by id.
func (m *MenuMutation) SetBrandID(id int) {
	m.brand = &id
}

// ClearBrand clears the "brand" edge to the Brand entity.
func (m *MenuMutation) ClearBrand() {
	m.clearedbrand = true
}

// BrandCleared reports if the "brand" edge to the Brand entity was cleared.
func (m *MenuMutation) BrandCleared() bool {
	return m.clearedbrand
}

// BrandID returns the "brand" edge ID in the mutation.
func (m *MenuMutation) BrandID() (id int, exists bool) {
	if m.brand != nil {
		return *m.brand, true
	}
	return
}

// BrandIDs returns the "brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) BrandIDs() (ids []int) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *MenuMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// AddItemIDs adds the "items" edge to the MenuItem entity by ids.
func (m *MenuMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the MenuItem entity.
func (m *MenuMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the MenuItem entity was cleared.
func (m *MenuMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the MenuItem entity by IDs.
func (m *MenuMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the MenuItem entity.
func (m *MenuMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *MenuMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *MenuMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.active != nil {
		fields = append(fields, menu.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldName:
		return m.Name()
	case menu.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.brand != nil {
		edges = append(edges, menu.EdgeBrand)
	}
	if m.items != nil {
		edges = append(edges, menu.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditems != nil {
		edges = append(edges, menu.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbrand {
		edges = append(edges, menu.EdgeBrand)
	}
	if m.cleareditems {
		edges = append(edges, menu.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeBrand:
		return m.clearedbrand
	case menu.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeBrand:
		m.ClearBrand()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeBrand:
		m.ResetBrand()
		return nil
	case menu.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// MenuItemMutation represents an operation that mutates the MenuItem nodes in the graph.
type MenuItemMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	price              *float64
	addprice           *float64
	prep_time          *int
	addprep_time       *int
	equipment_needed   *string
	clearedFields      map[string]struct{}
	menu               *int
	clearedmenu        bool
	ingredients        map[int]struct{}
	removedingredients map[int]struct{}
	clearedingredients bool
	order_items        map[int]struct{}
	removedorder_items map[int]struct{}
	clearedorder_items bool
	done               bool
	oldValue           func(context.Context) (*MenuItem, error)
	predicates         []predicate.MenuItem
}

var _ ent.Mutation = (*MenuItemMutation)(nil)

// menuitemOption allows management of the mutation configuration using functional options.
type menuitemOption func(*MenuItemMutation)

// newMenuItemMutation creates new mutation for the MenuItem entity.
func newMenuItemMutation(c config, op Op, opts ...menuitemOption) *MenuItemMutation {
	m := &MenuItemMutation{
		config:        c,
		op:            op,
		typ:           TypeMenuItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuItemID sets the ID field of the mutation.
func withMenuItemID(id int) menuitemOption {
	return func(m *MenuItemMutation) {
		var (
			err   error
			once  sync.Once
			value *MenuItem
		)
		m.oldValue = func(ctx context.Context) (*MenuItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MenuItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenuItem sets the old MenuItem of the mutation.
func withMenuItem(node *MenuItem) menuitemOption {
	return func(m *MenuItemMutation) {
		m.oldValue = func(context.Context) (*MenuItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MenuItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MenuItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MenuItemMutation) ResetName() {
	m.name = nil
}

// SetPrice sets the "price" field.
func (m *MenuItemMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *MenuItemMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *MenuItemMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *MenuItemMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *MenuItemMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetPrepTime sets the "prep_time" field.
func (m *MenuItemMutation) SetPrepTime(i int) {
	m.prep_time = &i
	m.addprep_time = nil
}

// PrepTime returns the value of the "prep_time" field in the mutation.
func (m *MenuItemMutation) PrepTime() (r int, exists bool) {
	v := m.prep_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPrepTime returns the old "prep_time" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldPrepTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrepTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrepTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrepTime: %w", err)
	}
	return oldValue.PrepTime, nil
}

// AddPrepTime adds i to the "prep_time" field.
func (m *MenuItemMutation) AddPrepTime(i int) {
	if m.addprep_time != nil {
		*m.addprep_time += i
	} else {
		m.addprep_time = &i
	}
}

// AddedPrepTime returns the value that was added to the "prep_time" field in this mutation.
func (m *MenuItemMutation) AddedPrepTime() (r int, exists bool) {
	v := m.addprep_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrepTime resets all changes to the "prep_time" field.
func (m *MenuItemMutation) ResetPrepTime() {
	m.prep_time = nil
	m.addprep_time = nil
}

// SetEquipmentNeeded sets the "equipment_needed" field.
func (m *MenuItemMutation) SetEquipmentNeeded(s string) {
	m.equipment_needed = &s
}

// EquipmentNeeded returns the value of the "equipment_needed" field in the mutation.
func (m *MenuItemMutation) EquipmentNeeded() (r string, exists bool) {
	v := m.equipment_needed
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipmentNeeded returns the old "equipment_needed" field's value of the MenuItem entity.
// If the MenuItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuItemMutation) OldEquipmentNeeded(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipmentNeeded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipmentNeeded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipmentNeeded: %w", err)
	}
	return oldValue.EquipmentNeeded, nil
}

// ResetEquipmentNeeded resets all changes to the "equipment_needed" field.
func (m *MenuItemMutation) ResetEquipmentNeeded() {
	m.equipment_needed = nil
}

// SetMenuID sets the "menu" edge to the Menu entity by id.
func (m *MenuItemMutation) SetMenuID(id int) {
	m.menu = &id
}

// ClearMenu clears the "menu" edge to the Menu entity.
func (m *MenuItemMutation) ClearMenu() {
	m.clearedmenu = true
}

// MenuCleared reports if the "menu" edge to the Menu entity was cleared.
func (m *MenuItemMutation) MenuCleared() bool {
	return m.clearedmenu
}

// MenuID returns the "menu" edge ID in the mutation.
func (m *MenuItemMutation) MenuID() (id int, exists bool) {
	if m.menu != nil {
		return *m.menu, true
	}
	return
}

// MenuIDs returns the "menu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MenuID instead. It exists only for internal usage by the builders.
func (m *MenuItemMutation) MenuIDs() (ids []int) {
	if id := m.menu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMenu resets all changes to the "menu" edge.
func (m *MenuItemMutation) ResetMenu() {
	m.menu = nil
	m.clearedmenu = false
}

// AddIngredientIDs adds the "ingredients" edge to the Ingredient entity by ids.
func (m *MenuItemMutation) AddIngredientIDs(ids ...int) {
	if m.ingredients == nil {
		m.ingredients = make(map[int]struct{})
	}
	for i := range ids {
		m.ingredients[ids[i]] = struct{}{}
	}
}

// ClearIngredients clears the "ingredients" edge to the Ingredient entity.
func (m *MenuItemMutation) ClearIngredients() {
	m.clearedingredients = true
}

// IngredientsCleared reports if the "ingredients" edge to the Ingredient entity was cleared.
func (m *MenuItemMutation) IngredientsCleared() bool {
	return m.clearedingredients
}

// RemoveIngredientIDs removes the "ingredients" edge to the Ingredient entity by IDs.
func (m *MenuItemMutation) RemoveIngredientIDs(ids ...int) {
	if m.removedingredients == nil {
		m.removedingredients = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ingredients, ids[i])
		m.removedingredients[ids[i]] = struct{}{}
	}
}

// RemovedIngredients returns the removed IDs of the "ingredients" edge to the Ingredient entity.
func (m *MenuItemMutation) RemovedIngredientsIDs() (ids []int) {
	for id := range m.removedingredients {
		ids = append(ids, id)
	}
	return
}

// IngredientsIDs returns the "ingredients" edge IDs in the mutation.
func (m *MenuItemMutation) IngredientsIDs() (ids []int) {
	for id := range m.ingredients {
		ids = append(ids, id)
	}
	return
}

// ResetIngredients resets all changes to the "ingredients" edge.
func (m *MenuItemMutation) ResetIngredients() {
	m.ingredients = nil
	m.clearedingredients = false
	m.removedingredients = nil
}

// AddOrderItemIDs adds the "order_items" edge to the OrderItem entity by ids.
func (m *MenuItemMutation) AddOrderItemIDs(ids ...int) {
	if m.order_items == nil {
		m.order_items = make(map[int]struct{})
	}
	for i := range ids {
		m.order_items[ids[i]] = struct{}{}
	}
}

// ClearOrderItems clears the "order_items" edge to the OrderItem entity.
func (m *MenuItemMutation) ClearOrderItems() {
	m.clearedorder_items = true
}

// OrderItemsCleared reports if the "order_items" edge to the OrderItem entity was cleared.
func (m *MenuItemMutation) OrderItemsCleared() bool {
	return m.clearedorder_items
}

// RemoveOrderItemIDs removes the "order_items" edge to the OrderItem entity by IDs.
func (m *MenuItemMutation) RemoveOrderItemIDs(ids ...int) {
	if m.removedorder_items == nil {
		m.removedorder_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.order_items, ids[i])
		m.removedorder_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderItems returns the removed IDs of the "order_items" edge to the OrderItem entity.
func (m *MenuItemMutation) RemovedOrderItemsIDs() (ids []int) {
	for id := range m.removedorder_items {
		ids = append(ids, id)
	}
	return
}

// OrderItemsIDs returns the "order_items" edge IDs in the mutation.
func (m *MenuItemMutation) OrderItemsIDs() (ids []int) {
	for id := range m.order_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItems resets all changes to the "order_items" edge.
func (m *MenuItemMutation) ResetOrderItems() {
	m.order_items = nil
	m.clearedorder_items = false
	m.removedorder_items = nil
}

// Where appends a list predicates to the MenuItemMutation builder.
func (m *MenuItemMutation) Where(ps ...predicate.MenuItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MenuItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MenuItem).
func (m *MenuItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuItemMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, menuitem.FieldName)
	}
	if m.price != nil {
		fields = append(fields, menuitem.FieldPrice)
	}
	if m.prep_time != nil {
		fields = append(fields, menuitem.FieldPrepTime)
	}
	if m.equipment_needed != nil {
		fields = append(fields, menuitem.FieldEquipmentNeeded)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menuitem.FieldName:
		return m.Name()
	case menuitem.FieldPrice:
		return m.Price()
	case menuitem.FieldPrepTime:
		return m.PrepTime()
	case menuitem.FieldEquipmentNeeded:
		return m.EquipmentNeeded()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menuitem.FieldName:
		return m.OldName(ctx)
	case menuitem.FieldPrice:
		return m.OldPrice(ctx)
	case menuitem.FieldPrepTime:
		return m.OldPrepTime(ctx)
	case menuitem.FieldEquipmentNeeded:
		return m.OldEquipmentNeeded(ctx)
	}
	return nil, fmt.Errorf("unknown MenuItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menuitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menuitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case menuitem.FieldPrepTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrepTime(v)
		return nil
	case menuitem.FieldEquipmentNeeded:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipmentNeeded(v)
		return nil
	}
	return fmt.Errorf("unknown MenuItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuItemMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, menuitem.FieldPrice)
	}
	if m.addprep_time != nil {
		fields = append(fields, menuitem.FieldPrepTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menuitem.FieldPrice:
		return m.AddedPrice()
	case menuitem.FieldPrepTime:
		return m.AddedPrepTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menuitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case menuitem.FieldPrepTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrepTime(v)
		return nil
	}
	return fmt.Errorf("unknown MenuItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MenuItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuItemMutation) ResetField(name string) error {
	switch name {
	case menuitem.FieldName:
		m.ResetName()
		return nil
	case menuitem.FieldPrice:
		m.ResetPrice()
		return nil
	case menuitem.FieldPrepTime:
		m.ResetPrepTime()
		return nil
	case menuitem.FieldEquipmentNeeded:
		m.ResetEquipmentNeeded()
		return nil
	}
	return fmt.Errorf("unknown MenuItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.menu != nil {
		edges = append(edges, menuitem.EdgeMenu)
	}
	if m.ingredients != nil {
		edges = append(edges, menuitem.EdgeIngredients)
	}
	if m.order_items != nil {
		edges = append(edges, menuitem.EdgeOrderItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menuitem.EdgeMenu:
		if id := m.menu; id != nil {
			return []ent.Value{*id}
		}
	case menuitem.EdgeIngredients:
		ids := make([]ent.Value, 0, len(m.ingredients))
		for id := range m.ingredients {
			ids = append(ids, id)
		}
		return ids
	case menuitem.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.order_items))
		for id := range m.order_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedingredients != nil {
		edges = append(edges, menuitem.EdgeIngredients)
	}
	if m.removedorder_items != nil {
		edges = append(edges, menuitem.EdgeOrderItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menuitem.EdgeIngredients:
		ids := make([]ent.Value, 0, len(m.removedingredients))
		for id := range m.removedingredients {
			ids = append(ids, id)
		}
		return ids
	case menuitem.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.removedorder_items))
		for id := range m.removedorder_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmenu {
		edges = append(edges, menuitem.EdgeMenu)
	}
	if m.clearedingredients {
		edges = append(edges, menuitem.EdgeIngredients)
	}
	if m.clearedorder_items {
		edges = append(edges, menuitem.EdgeOrderItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuItemMutation) EdgeCleared(name string) bool {
	switch name {
	case menuitem.EdgeMenu:
		return m.clearedmenu
	case menuitem.EdgeIngredients:
		return m.clearedingredients
	case menuitem.EdgeOrderItems:
		return m.clearedorder_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuItemMutation) ClearEdge(name string) error {
	switch name {
	case menuitem.EdgeMenu:
		m.ClearMenu()
		return nil
	}
	return fmt.Errorf("unknown MenuItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuItemMutation) ResetEdge(name string) error {
	switch name {
	case menuitem.EdgeMenu:
		m.ResetMenu()
		return nil
	case menuitem.EdgeIngredients:
		m.ResetIngredients()
		return nil
	case menuitem.EdgeOrderItems:
		m.ResetOrderItems()
		return nil
	}
	return fmt.Errorf("unknown MenuItem edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	created_at                  *time.Time
	required_by                 *time.Time
	status                      *string
	total_price                 *float64
	addtotal_price              *float64
	clearedFields               map[string]struct{}
	brand                       *int
	clearedbrand                bool
	items                       map[int]struct{}
	removeditems                map[int]struct{}
	cleareditems                bool
	resource_allocations        map[int]struct{}
	removedresource_allocations map[int]struct{}
	clearedresource_allocations bool
	done                        bool
	oldValue                    func(context.Context) (*Order, error)
	predicates                  []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetRequiredBy sets the "required_by" field.
func (m *OrderMutation) SetRequiredBy(t time.Time) {
	m.required_by = &t
}

// RequiredBy returns the value of the "required_by" field in the mutation.
func (m *OrderMutation) RequiredBy() (r time.Time, exists bool) {
	v := m.required_by
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredBy returns the old "required_by" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRequiredBy(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredBy: %w", err)
	}
	return oldValue.RequiredBy, nil
}

// ResetRequiredBy resets all changes to the "required_by" field.
func (m *OrderMutation) ResetRequiredBy() {
	m.required_by = nil
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
}

// SetTotalPrice sets the "total_price" field.
func (m *OrderMutation) SetTotalPrice(f float64) {
	m.total_price = &f
	m.addtotal_price = nil
}

// TotalPrice returns the value of the "total_price" field in the mutation.
func (m *OrderMutation) TotalPrice() (r float64, exists bool) {
	v := m.total_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPrice returns the old "total_price" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTotalPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPrice: %w", err)
	}
	return oldValue.TotalPrice, nil
}

// AddTotalPrice adds f to the "total_price" field.
func (m *OrderMutation) AddTotalPrice(f float64) {
	if m.addtotal_price != nil {
		*m.addtotal_price += f
	} else {
		m.addtotal_price = &f
	}
}

// AddedTotalPrice returns the value that was added to the "total_price" field in this mutation.
func (m *OrderMutation) AddedTotalPrice() (r float64, exists bool) {
	v := m.addtotal_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPrice resets all changes to the "total_price" field.
func (m *OrderMutation) ResetTotalPrice() {
	m.total_price = nil
	m.addtotal_price = nil
}

// SetBrandID sets the "brand" edge to the Brand entity by id.
func (m *OrderMutation) SetBrandID(id int) {
	m.brand = &id
}

// ClearBrand clears the "brand" edge to the Brand entity.
func (m *OrderMutation) ClearBrand() {
	m.clearedbrand = true
}

// BrandCleared reports if the "brand" edge to the Brand entity was cleared.
func (m *OrderMutation) BrandCleared() bool {
	return m.clearedbrand
}

// BrandID returns the "brand" edge ID in the mutation.
func (m *OrderMutation) BrandID() (id int, exists bool) {
	if m.brand != nil {
		return *m.brand, true
	}
	return
}

// BrandIDs returns the "brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) BrandIDs() (ids []int) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *OrderMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// AddItemIDs adds the "items" edge to the OrderItem entity by ids.
func (m *OrderMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the OrderItem entity.
func (m *OrderMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the OrderItem entity was cleared.
func (m *OrderMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the OrderItem entity by IDs.
func (m *OrderMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the OrderItem entity.
func (m *OrderMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *OrderMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *OrderMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddResourceAllocationIDs adds the "resource_allocations" edge to the ResourceAllocation entity by ids.
func (m *OrderMutation) AddResourceAllocationIDs(ids ...int) {
	if m.resource_allocations == nil {
		m.resource_allocations = make(map[int]struct{})
	}
	for i := range ids {
		m.resource_allocations[ids[i]] = struct{}{}
	}
}

// ClearResourceAllocations clears the "resource_allocations" edge to the ResourceAllocation entity.
func (m *OrderMutation) ClearResourceAllocations() {
	m.clearedresource_allocations = true
}

// ResourceAllocationsCleared reports if the "resource_allocations" edge to the ResourceAllocation entity was cleared.
func (m *OrderMutation) ResourceAllocationsCleared() bool {
	return m.clearedresource_allocations
}

// RemoveResourceAllocationIDs removes the "resource_allocations" edge to the ResourceAllocation entity by IDs.
func (m *OrderMutation) RemoveResourceAllocationIDs(ids ...int) {
	if m.removedresource_allocations == nil {
		m.removedresource_allocations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resource_allocations, ids[i])
		m.removedresource_allocations[ids[i]] = struct{}{}
	}
}

// RemovedResourceAllocations returns the removed IDs of the "resource_allocations" edge to the ResourceAllocation entity.
func (m *OrderMutation) RemovedResourceAllocationsIDs() (ids []int) {
	for id := range m.removedresource_allocations {
		ids = append(ids, id)
	}
	return
}

// ResourceAllocationsIDs returns the "resource_allocations" edge IDs in the mutation.
func (m *OrderMutation) ResourceAllocationsIDs() (ids []int) {
	for id := range m.resource_allocations {
		ids = append(ids, id)
	}
	return
}

// ResetResourceAllocations resets all changes to the "resource_allocations" edge.
func (m *OrderMutation) ResetResourceAllocations() {
	m.resource_allocations = nil
	m.clearedresource_allocations = false
	m.removedresource_allocations = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.required_by != nil {
		fields = append(fields, order.FieldRequiredBy)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.total_price != nil {
		fields = append(fields, order.FieldTotalPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldRequiredBy:
		return m.RequiredBy()
	case order.FieldStatus:
		return m.Status()
	case order.FieldTotalPrice:
		return m.TotalPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldRequiredBy:
		return m.OldRequiredBy(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldTotalPrice:
		return m.OldTotalPrice(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldRequiredBy:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredBy(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_price != nil {
		fields = append(fields, order.FieldTotalPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldTotalPrice:
		return m.AddedTotalPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldRequiredBy:
		m.ResetRequiredBy()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldTotalPrice:
		m.ResetTotalPrice()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.brand != nil {
		edges = append(edges, order.EdgeBrand)
	}
	if m.items != nil {
		edges = append(edges, order.EdgeItems)
	}
	if m.resource_allocations != nil {
		edges = append(edges, order.EdgeResourceAllocations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeResourceAllocations:
		ids := make([]ent.Value, 0, len(m.resource_allocations))
		for id := range m.resource_allocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeditems != nil {
		edges = append(edges, order.EdgeItems)
	}
	if m.removedresource_allocations != nil {
		edges = append(edges, order.EdgeResourceAllocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeResourceAllocations:
		ids := make([]ent.Value, 0, len(m.removedresource_allocations))
		for id := range m.removedresource_allocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbrand {
		edges = append(edges, order.EdgeBrand)
	}
	if m.cleareditems {
		edges = append(edges, order.EdgeItems)
	}
	if m.clearedresource_allocations {
		edges = append(edges, order.EdgeResourceAllocations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeBrand:
		return m.clearedbrand
	case order.EdgeItems:
		return m.cleareditems
	case order.EdgeResourceAllocations:
		return m.clearedresource_allocations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeBrand:
		m.ClearBrand()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeBrand:
		m.ResetBrand()
		return nil
	case order.EdgeItems:
		m.ResetItems()
		return nil
	case order.EdgeResourceAllocations:
		m.ResetResourceAllocations()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	quantity             *int
	addquantity          *int
	special_instructions *string
	clearedFields        map[string]struct{}
	_order               *int
	cleared_order        bool
	menu_item            *int
	clearedmenu_item     bool
	done                 bool
	oldValue             func(context.Context) (*OrderItem, error)
	predicates           []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id int) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *OrderItemMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderItemMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *OrderItemMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *OrderItemMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetSpecialInstructions sets the "special_instructions" field.
func (m *OrderItemMutation) SetSpecialInstructions(s string) {
	m.special_instructions = &s
}

// SpecialInstructions returns the value of the "special_instructions" field in the mutation.
func (m *OrderItemMutation) SpecialInstructions() (r string, exists bool) {
	v := m.special_instructions
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialInstructions returns the old "special_instructions" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldSpecialInstructions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecialInstructions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecialInstructions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialInstructions: %w", err)
	}
	return oldValue.SpecialInstructions, nil
}

// ClearSpecialInstructions clears the value of the "special_instructions" field.
func (m *OrderItemMutation) ClearSpecialInstructions() {
	m.special_instructions = nil
	m.clearedFields[orderitem.FieldSpecialInstructions] = struct{}{}
}

// SpecialInstructionsCleared returns if the "special_instructions" field was cleared in this mutation.
func (m *OrderItemMutation) SpecialInstructionsCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldSpecialInstructions]
	return ok
}

// ResetSpecialInstructions resets all changes to the "special_instructions" field.
func (m *OrderItemMutation) ResetSpecialInstructions() {
	m.special_instructions = nil
	delete(m.clearedFields, orderitem.FieldSpecialInstructions)
}

// SetOrderID sets the "order" edge to the Order entity by id.
func (m *OrderItemMutation) SetOrderID(id int) {
	m._order = &id
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderItemMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderItemMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderID returns the "order" edge ID in the mutation.
func (m *OrderItemMutation) OrderID() (id int, exists bool) {
	if m._order != nil {
		return *m._order, true
	}
	return
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderItemMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// SetMenuItemID sets the "menu_item" edge to the MenuItem entity by id.
func (m *OrderItemMutation) SetMenuItemID(id int) {
	m.menu_item = &id
}

// ClearMenuItem clears the "menu_item" edge to the MenuItem entity.
func (m *OrderItemMutation) ClearMenuItem() {
	m.clearedmenu_item = true
}

// MenuItemCleared reports if the "menu_item" edge to the MenuItem entity was cleared.
func (m *OrderItemMutation) MenuItemCleared() bool {
	return m.clearedmenu_item
}

// MenuItemID returns the "menu_item" edge ID in the mutation.
func (m *OrderItemMutation) MenuItemID() (id int, exists bool) {
	if m.menu_item != nil {
		return *m.menu_item, true
	}
	return
}

// MenuItemIDs returns the "menu_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MenuItemID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) MenuItemIDs() (ids []int) {
	if id := m.menu_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMenuItem resets all changes to the "menu_item" edge.
func (m *OrderItemMutation) ResetMenuItem() {
	m.menu_item = nil
	m.clearedmenu_item = false
}

// Where appends a list predicates to the OrderItemMutation builder.
func (m *OrderItemMutation) Where(ps ...predicate.OrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.quantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	if m.special_instructions != nil {
		fields = append(fields, orderitem.FieldSpecialInstructions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldQuantity:
		return m.Quantity()
	case orderitem.FieldSpecialInstructions:
		return m.SpecialInstructions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderitem.FieldSpecialInstructions:
		return m.OldSpecialInstructions(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderitem.FieldSpecialInstructions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialInstructions(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitem.FieldSpecialInstructions) {
		fields = append(fields, orderitem.FieldSpecialInstructions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	switch name {
	case orderitem.FieldSpecialInstructions:
		m.ClearSpecialInstructions()
		return nil
	}
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderitem.FieldSpecialInstructions:
		m.ResetSpecialInstructions()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	if m.menu_item != nil {
		edges = append(edges, orderitem.EdgeMenuItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case orderitem.EdgeMenuItem:
		if id := m.menu_item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_order {
		edges = append(edges, orderitem.EdgeOrder)
	}
	if m.clearedmenu_item {
		edges = append(edges, orderitem.EdgeMenuItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeOrder:
		return m.cleared_order
	case orderitem.EdgeMenuItem:
		return m.clearedmenu_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ClearOrder()
		return nil
	case orderitem.EdgeMenuItem:
		m.ClearMenuItem()
		return nil
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ResetOrder()
		return nil
	case orderitem.EdgeMenuItem:
		m.ResetMenuItem()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// ResourceAllocationMutation represents an operation that mutates the ResourceAllocation nodes in the graph.
type ResourceAllocationMutation struct {
	config
	op              Op
	typ             string
	id              *int
	start_time      *time.Time
	end_time        *time.Time
	status          *string
	clearedFields   map[string]struct{}
	resource        *int
	clearedresource bool
	_order          *int
	cleared_order   bool
	shift           *int
	clearedshift    bool
	done            bool
	oldValue        func(context.Context) (*ResourceAllocation, error)
	predicates      []predicate.ResourceAllocation
}

var _ ent.Mutation = (*ResourceAllocationMutation)(nil)

// resourceallocationOption allows management of the mutation configuration using functional options.
type resourceallocationOption func(*ResourceAllocationMutation)

// newResourceAllocationMutation creates new mutation for the ResourceAllocation entity.
func newResourceAllocationMutation(c config, op Op, opts ...resourceallocationOption) *ResourceAllocationMutation {
	m := &ResourceAllocationMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceAllocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceAllocationID sets the ID field of the mutation.
func withResourceAllocationID(id int) resourceallocationOption {
	return func(m *ResourceAllocationMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceAllocation
		)
		m.oldValue = func(ctx context.Context) (*ResourceAllocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceAllocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceAllocation sets the old ResourceAllocation of the mutation.
func withResourceAllocation(node *ResourceAllocation) resourceallocationOption {
	return func(m *ResourceAllocationMutation) {
		m.oldValue = func(context.Context) (*ResourceAllocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceAllocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceAllocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceAllocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceAllocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceAllocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartTime sets the "start_time" field.
func (m *ResourceAllocationMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ResourceAllocationMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the ResourceAllocation entity.
// If the ResourceAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceAllocationMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ResourceAllocationMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *ResourceAllocationMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ResourceAllocationMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the ResourceAllocation entity.
// If the ResourceAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceAllocationMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ResourceAllocationMutation) ResetEndTime() {
	m.end_time = nil
}

// SetStatus sets the "status" field.
func (m *ResourceAllocationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ResourceAllocationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ResourceAllocation entity.
// If the ResourceAllocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceAllocationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ResourceAllocationMutation) ResetStatus() {
	m.status = nil
}

// SetResourceID sets the "resource" edge to the KitchenResource entity by id.
func (m *ResourceAllocationMutation) SetResourceID(id int) {
	m.resource = &id
}

// ClearResource clears the "resource" edge to the KitchenResource entity.
func (m *ResourceAllocationMutation) ClearResource() {
	m.clearedresource = true
}

// ResourceCleared reports if the "resource" edge to the KitchenResource entity was cleared.
func (m *ResourceAllocationMutation) ResourceCleared() bool {
	return m.clearedresource
}

// ResourceID returns the "resource" edge ID in the mutation.
func (m *ResourceAllocationMutation) ResourceID() (id int, exists bool) {
	if m.resource != nil {
		return *m.resource, true
	}
	return
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *ResourceAllocationMutation) ResourceIDs() (ids []int) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *ResourceAllocationMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// SetOrderID sets the "order" edge to the Order entity by id.
func (m *ResourceAllocationMutation) SetOrderID(id int) {
	m._order = &id
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *ResourceAllocationMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *ResourceAllocationMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderID returns the "order" edge ID in the mutation.
func (m *ResourceAllocationMutation) OrderID() (id int, exists bool) {
	if m._order != nil {
		return *m._order, true
	}
	return
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *ResourceAllocationMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *ResourceAllocationMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// SetShiftID sets the "shift" edge to the Shift entity by id.
func (m *ResourceAllocationMutation) SetShiftID(id int) {
	m.shift = &id
}

// ClearShift clears the "shift" edge to the Shift entity.
func (m *ResourceAllocationMutation) ClearShift() {
	m.clearedshift = true
}

// ShiftCleared reports if the "shift" edge to the Shift entity was cleared.
func (m *ResourceAllocationMutation) ShiftCleared() bool {
	return m.clearedshift
}

// ShiftID returns the "shift" edge ID in the mutation.
func (m *ResourceAllocationMutation) ShiftID() (id int, exists bool) {
	if m.shift != nil {
		return *m.shift, true
	}
	return
}

// ShiftIDs returns the "shift" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShiftID instead. It exists only for internal usage by the builders.
func (m *ResourceAllocationMutation) ShiftIDs() (ids []int) {
	if id := m.shift; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShift resets all changes to the "shift" edge.
func (m *ResourceAllocationMutation) ResetShift() {
	m.shift = nil
	m.clearedshift = false
}

// Where appends a list predicates to the ResourceAllocationMutation builder.
func (m *ResourceAllocationMutation) Where(ps ...predicate.ResourceAllocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceAllocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceAllocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResourceAllocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceAllocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceAllocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResourceAllocation).
func (m *ResourceAllocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceAllocationMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.start_time != nil {
		fields = append(fields, resourceallocation.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, resourceallocation.FieldEndTime)
	}
	if m.status != nil {
		fields = append(fields, resourceallocation.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceAllocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourceallocation.FieldStartTime:
		return m.StartTime()
	case resourceallocation.FieldEndTime:
		return m.EndTime()
	case resourceallocation.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceAllocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourceallocation.FieldStartTime:
		return m.OldStartTime(ctx)
	case resourceallocation.FieldEndTime:
		return m.OldEndTime(ctx)
	case resourceallocation.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceAllocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceAllocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourceallocation.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case resourceallocation.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case resourceallocation.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceAllocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceAllocationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceAllocationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceAllocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResourceAllocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceAllocationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceAllocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceAllocationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ResourceAllocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceAllocationMutation) ResetField(name string) error {
	switch name {
	case resourceallocation.FieldStartTime:
		m.ResetStartTime()
		return nil
	case resourceallocation.FieldEndTime:
		m.ResetEndTime()
		return nil
	case resourceallocation.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ResourceAllocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceAllocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.resource != nil {
		edges = append(edges, resourceallocation.EdgeResource)
	}
	if m._order != nil {
		edges = append(edges, resourceallocation.EdgeOrder)
	}
	if m.shift != nil {
		edges = append(edges, resourceallocation.EdgeShift)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceAllocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resourceallocation.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	case resourceallocation.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case resourceallocation.EdgeShift:
		if id := m.shift; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceAllocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceAllocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceAllocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedresource {
		edges = append(edges, resourceallocation.EdgeResource)
	}
	if m.cleared_order {
		edges = append(edges, resourceallocation.EdgeOrder)
	}
	if m.clearedshift {
		edges = append(edges, resourceallocation.EdgeShift)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceAllocationMutation) EdgeCleared(name string) bool {
	switch name {
	case resourceallocation.EdgeResource:
		return m.clearedresource
	case resourceallocation.EdgeOrder:
		return m.cleared_order
	case resourceallocation.EdgeShift:
		return m.clearedshift
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceAllocationMutation) ClearEdge(name string) error {
	switch name {
	case resourceallocation.EdgeResource:
		m.ClearResource()
		return nil
	case resourceallocation.EdgeOrder:
		m.ClearOrder()
		return nil
	case resourceallocation.EdgeShift:
		m.ClearShift()
		return nil
	}
	return fmt.Errorf("unknown ResourceAllocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceAllocationMutation) ResetEdge(name string) error {
	switch name {
	case resourceallocation.EdgeResource:
		m.ResetResource()
		return nil
	case resourceallocation.EdgeOrder:
		m.ResetOrder()
		return nil
	case resourceallocation.EdgeShift:
		m.ResetShift()
		return nil
	}
	return fmt.Errorf("unknown ResourceAllocation edge %s", name)
}

// ShiftMutation represents an operation that mutates the Shift nodes in the graph.
type ShiftMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	start_time         *time.Time
	end_time           *time.Time
	clearedFields      map[string]struct{}
	staff              *int
	clearedstaff       bool
	allocations        map[int]struct{}
	removedallocations map[int]struct{}
	clearedallocations bool
	done               bool
	oldValue           func(context.Context) (*Shift, error)
	predicates         []predicate.Shift
}

var _ ent.Mutation = (*ShiftMutation)(nil)

// shiftOption allows management of the mutation configuration using functional options.
type shiftOption func(*ShiftMutation)

// newShiftMutation creates new mutation for the Shift entity.
func newShiftMutation(c config, op Op, opts ...shiftOption) *ShiftMutation {
	m := &ShiftMutation{
		config:        c,
		op:            op,
		typ:           TypeShift,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShiftID sets the ID field of the mutation.
func withShiftID(id int) shiftOption {
	return func(m *ShiftMutation) {
		var (
			err   error
			once  sync.Once
			value *Shift
		)
		m.oldValue = func(ctx context.Context) (*Shift, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Shift.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShift sets the old Shift of the mutation.
func withShift(node *Shift) shiftOption {
	return func(m *ShiftMutation) {
		m.oldValue = func(context.Context) (*Shift, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShiftMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShiftMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShiftMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShiftMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Shift.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartTime sets the "start_time" field.
func (m *ShiftMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ShiftMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Shift entity.
// If the Shift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShiftMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ShiftMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *ShiftMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ShiftMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Shift entity.
// If the Shift object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShiftMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ShiftMutation) ResetEndTime() {
	m.end_time = nil
}

// SetStaffID sets the "staff" edge to the Staff entity by id.
func (m *ShiftMutation) SetStaffID(id int) {
	m.staff = &id
}

// ClearStaff clears the "staff" edge to the Staff entity.
func (m *ShiftMutation) ClearStaff() {
	m.clearedstaff = true
}

// StaffCleared reports if the "staff" edge to the Staff entity was cleared.
func (m *ShiftMutation) StaffCleared() bool {
	return m.clearedstaff
}

// StaffID returns the "staff" edge ID in the mutation.
func (m *ShiftMutation) StaffID() (id int, exists bool) {
	if m.staff != nil {
		return *m.staff, true
	}
	return
}

// StaffIDs returns the "staff" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StaffID instead. It exists only for internal usage by the builders.
func (m *ShiftMutation) StaffIDs() (ids []int) {
	if id := m.staff; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStaff resets all changes to the "staff" edge.
func (m *ShiftMutation) ResetStaff() {
	m.staff = nil
	m.clearedstaff = false
}

// AddAllocationIDs adds the "allocations" edge to the ResourceAllocation entity by ids.
func (m *ShiftMutation) AddAllocationIDs(ids ...int) {
	if m.allocations == nil {
		m.allocations = make(map[int]struct{})
	}
	for i := range ids {
		m.allocations[ids[i]] = struct{}{}
	}
}

// ClearAllocations clears the "allocations" edge to the ResourceAllocation entity.
func (m *ShiftMutation) ClearAllocations() {
	m.clearedallocations = true
}

// AllocationsCleared reports if the "allocations" edge to the ResourceAllocation entity was cleared.
func (m *ShiftMutation) AllocationsCleared() bool {
	return m.clearedallocations
}

// RemoveAllocationIDs removes the "allocations" edge to the ResourceAllocation entity by IDs.
func (m *ShiftMutation) RemoveAllocationIDs(ids ...int) {
	if m.removedallocations == nil {
		m.removedallocations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.allocations, ids[i])
		m.removedallocations[ids[i]] = struct{}{}
	}
}

// RemovedAllocations returns the removed IDs of the "allocations" edge to the ResourceAllocation entity.
func (m *ShiftMutation) RemovedAllocationsIDs() (ids []int) {
	for id := range m.removedallocations {
		ids = append(ids, id)
	}
	return
}

// AllocationsIDs returns the "allocations" edge IDs in the mutation.
func (m *ShiftMutation) AllocationsIDs() (ids []int) {
	for id := range m.allocations {
		ids = append(ids, id)
	}
	return
}

// ResetAllocations resets all changes to the "allocations" edge.
func (m *ShiftMutation) ResetAllocations() {
	m.allocations = nil
	m.clearedallocations = false
	m.removedallocations = nil
}

// Where appends a list predicates to the ShiftMutation builder.
func (m *ShiftMutation) Where(ps ...predicate.Shift) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShiftMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShiftMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Shift, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShiftMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShiftMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Shift).
func (m *ShiftMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShiftMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.start_time != nil {
		fields = append(fields, shift.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, shift.FieldEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShiftMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shift.FieldStartTime:
		return m.StartTime()
	case shift.FieldEndTime:
		return m.EndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShiftMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shift.FieldStartTime:
		return m.OldStartTime(ctx)
	case shift.FieldEndTime:
		return m.OldEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown Shift field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShiftMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shift.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case shift.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown Shift field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShiftMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShiftMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShiftMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Shift numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShiftMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShiftMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShiftMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Shift nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShiftMutation) ResetField(name string) error {
	switch name {
	case shift.FieldStartTime:
		m.ResetStartTime()
		return nil
	case shift.FieldEndTime:
		m.ResetEndTime()
		return nil
	}
	return fmt.Errorf("unknown Shift field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShiftMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.staff != nil {
		edges = append(edges, shift.EdgeStaff)
	}
	if m.allocations != nil {
		edges = append(edges, shift.EdgeAllocations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShiftMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shift.EdgeStaff:
		if id := m.staff; id != nil {
			return []ent.Value{*id}
		}
	case shift.EdgeAllocations:
		ids := make([]ent.Value, 0, len(m.allocations))
		for id := range m.allocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShiftMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedallocations != nil {
		edges = append(edges, shift.EdgeAllocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShiftMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case shift.EdgeAllocations:
		ids := make([]ent.Value, 0, len(m.removedallocations))
		for id := range m.removedallocations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShiftMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstaff {
		edges = append(edges, shift.EdgeStaff)
	}
	if m.clearedallocations {
		edges = append(edges, shift.EdgeAllocations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShiftMutation) EdgeCleared(name string) bool {
	switch name {
	case shift.EdgeStaff:
		return m.clearedstaff
	case shift.EdgeAllocations:
		return m.clearedallocations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShiftMutation) ClearEdge(name string) error {
	switch name {
	case shift.EdgeStaff:
		m.ClearStaff()
		return nil
	}
	return fmt.Errorf("unknown Shift unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShiftMutation) ResetEdge(name string) error {
	switch name {
	case shift.EdgeStaff:
		m.ResetStaff()
		return nil
	case shift.EdgeAllocations:
		m.ResetAllocations()
		return nil
	}
	return fmt.Errorf("unknown Shift edge %s", name)
}

// StaffMutation represents an operation that mutates the Staff nodes in the graph.
type StaffMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	role           *string
	skills         *string
	availability   *map[string][]string
	clearedFields  map[string]struct{}
	kitchen        *int
	clearedkitchen bool
	shifts         map[int]struct{}
	removedshifts  map[int]struct{}
	clearedshifts  bool
	done           bool
	oldValue       func(context.Context) (*Staff, error)
	predicates     []predicate.Staff
}

var _ ent.Mutation = (*StaffMutation)(nil)

// staffOption allows management of the mutation configuration using functional options.
type staffOption func(*StaffMutation)

// newStaffMutation creates new mutation for the Staff entity.
func newStaffMutation(c config, op Op, opts ...staffOption) *StaffMutation {
	m := &StaffMutation{
		config:        c,
		op:            op,
		typ:           TypeStaff,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStaffID sets the ID field of the mutation.
func withStaffID(id int) staffOption {
	return func(m *StaffMutation) {
		var (
			err   error
			once  sync.Once
			value *Staff
		)
		m.oldValue = func(ctx context.Context) (*Staff, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Staff.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaff sets the old Staff of the mutation.
func withStaff(node *Staff) staffOption {
	return func(m *StaffMutation) {
		m.oldValue = func(context.Context) (*Staff, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StaffMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StaffMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StaffMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StaffMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Staff.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *StaffMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StaffMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StaffMutation) ResetName() {
	m.name = nil
}

// SetRole sets the "role" field.
func (m *StaffMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *StaffMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *StaffMutation) ResetRole() {
	m.role = nil
}

// SetSkills sets the "skills" field.
func (m *StaffMutation) SetSkills(s string) {
	m.skills = &s
}

// Skills returns the value of the "skills" field in the mutation.
func (m *StaffMutation) Skills() (r string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldSkills(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// ResetSkills resets all changes to the "skills" field.
func (m *StaffMutation) ResetSkills() {
	m.skills = nil
}

// SetAvailability sets the "availability" field.
func (m *StaffMutation) SetAvailability(value map[string][]string) {
	m.availability = &value
}

// Availability returns the value of the "availability" field in the mutation.
func (m *StaffMutation) Availability() (r map[string][]string, exists bool) {
	v := m.availability
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailability returns the old "availability" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldAvailability(ctx context.Context) (v map[string][]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailability: %w", err)
	}
	return oldValue.Availability, nil
}

// ResetAvailability resets all changes to the "availability" field.
func (m *StaffMutation) ResetAvailability() {
	m.availability = nil
}

// SetKitchenID sets the "kitchen" edge to the Kitchen entity by id.
func (m *StaffMutation) SetKitchenID(id int) {
	m.kitchen = &id
}

// ClearKitchen clears the "kitchen" edge to the Kitchen entity.
func (m *StaffMutation) ClearKitchen() {
	m.clearedkitchen = true
}

// KitchenCleared reports if the "kitchen" edge to the Kitchen entity was cleared.
func (m *StaffMutation) KitchenCleared() bool {
	return m.clearedkitchen
}

// KitchenID returns the "kitchen" edge ID in the mutation.
func (m *StaffMutation) KitchenID() (id int, exists bool) {
	if m.kitchen != nil {
		return *m.kitchen, true
	}
	return
}

// KitchenIDs returns the "kitchen" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KitchenID instead. It exists only for internal usage by the builders.
func (m *StaffMutation) KitchenIDs() (ids []int) {
	if id := m.kitchen; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKitchen resets all changes to the "kitchen" edge.
func (m *StaffMutation) ResetKitchen() {
	m.kitchen = nil
	m.clearedkitchen = false
}

// AddShiftIDs adds the "shifts" edge to the Shift entity by ids.
func (m *StaffMutation) AddShiftIDs(ids ...int) {
	if m.shifts == nil {
		m.shifts = make(map[int]struct{})
	}
	for i := range ids {
		m.shifts[ids[i]] = struct{}{}
	}
}

// ClearShifts clears the "shifts" edge to the Shift entity.
func (m *StaffMutation) ClearShifts() {
	m.clearedshifts = true
}

// ShiftsCleared reports if the "shifts" edge to the Shift entity was cleared.
func (m *StaffMutation) ShiftsCleared() bool {
	return m.clearedshifts
}

// RemoveShiftIDs removes the "shifts" edge to the Shift entity by IDs.
func (m *StaffMutation) RemoveShiftIDs(ids ...int) {
	if m.removedshifts == nil {
		m.removedshifts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.shifts, ids[i])
		m.removedshifts[ids[i]] = struct{}{}
	}
}

// RemovedShifts returns the removed IDs of the "shifts" edge to the Shift entity.
func (m *StaffMutation) RemovedShiftsIDs() (ids []int) {
	for id := range m.removedshifts {
		ids = append(ids, id)
	}
	return
}

// ShiftsIDs returns the "shifts" edge IDs in the mutation.
func (m *StaffMutation) ShiftsIDs() (ids []int) {
	for id := range m.shifts {
		ids = append(ids, id)
	}
	return
}

// ResetShifts resets all changes to the "shifts" edge.
func (m *StaffMutation) ResetShifts() {
	m.shifts = nil
	m.clearedshifts = false
	m.removedshifts = nil
}

// Where appends a list predicates to the StaffMutation builder.
func (m *StaffMutation) Where(ps ...predicate.Staff) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StaffMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StaffMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Staff, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StaffMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StaffMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Staff).
func (m *StaffMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StaffMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, staff.FieldName)
	}
	if m.role != nil {
		fields = append(fields, staff.FieldRole)
	}
	if m.skills != nil {
		fields = append(fields, staff.FieldSkills)
	}
	if m.availability != nil {
		fields = append(fields, staff.FieldAvailability)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StaffMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staff.FieldName:
		return m.Name()
	case staff.FieldRole:
		return m.Role()
	case staff.FieldSkills:
		return m.Skills()
	case staff.FieldAvailability:
		return m.Availability()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StaffMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staff.FieldName:
		return m.OldName(ctx)
	case staff.FieldRole:
		return m.OldRole(ctx)
	case staff.FieldSkills:
		return m.OldSkills(ctx)
	case staff.FieldAvailability:
		return m.OldAvailability(ctx)
	}
	return nil, fmt.Errorf("unknown Staff field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staff.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case staff.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case staff.FieldSkills:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case staff.FieldAvailability:
		v, ok := value.(map[string][]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailability(v)
		return nil
	}
	return fmt.Errorf("unknown Staff field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StaffMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StaffMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Staff numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StaffMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StaffMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StaffMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Staff nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StaffMutation) ResetField(name string) error {
	switch name {
	case staff.FieldName:
		m.ResetName()
		return nil
	case staff.FieldRole:
		m.ResetRole()
		return nil
	case staff.FieldSkills:
		m.ResetSkills()
		return nil
	case staff.FieldAvailability:
		m.ResetAvailability()
		return nil
	}
	return fmt.Errorf("unknown Staff field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StaffMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.kitchen != nil {
		edges = append(edges, staff.EdgeKitchen)
	}
	if m.shifts != nil {
		edges = append(edges, staff.EdgeShifts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StaffMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case staff.EdgeKitchen:
		if id := m.kitchen; id != nil {
			return []ent.Value{*id}
		}
	case staff.EdgeShifts:
		ids := make([]ent.Value, 0, len(m.shifts))
		for id := range m.shifts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StaffMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedshifts != nil {
		edges = append(edges, staff.EdgeShifts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StaffMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case staff.EdgeShifts:
		ids := make([]ent.Value, 0, len(m.removedshifts))
		for id := range m.removedshifts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StaffMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedkitchen {
		edges = append(edges, staff.EdgeKitchen)
	}
	if m.clearedshifts {
		edges = append(edges, staff.EdgeShifts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StaffMutation) EdgeCleared(name string) bool {
	switch name {
	case staff.EdgeKitchen:
		return m.clearedkitchen
	case staff.EdgeShifts:
		return m.clearedshifts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StaffMutation) ClearEdge(name string) error {
	switch name {
	case staff.EdgeKitchen:
		m.ClearKitchen()
		return nil
	}
	return fmt.Errorf("unknown Staff unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StaffMutation) ResetEdge(name string) error {
	switch name {
	case staff.EdgeKitchen:
		m.ResetKitchen()
		return nil
	case staff.EdgeShifts:
		m.ResetShifts()
		return nil
	}
	return fmt.Errorf("unknown Staff edge %s", name)
}
