// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"project/ent/migrate"

	"project/ent/brand"
	"project/ent/ingredient"
	"project/ent/inventoryitem"
	"project/ent/kitchen"
	"project/ent/kitchenresource"
	"project/ent/menu"
	"project/ent/menuitem"
	"project/ent/order"
	"project/ent/orderitem"
	"project/ent/resourceallocation"
	"project/ent/shift"
	"project/ent/staff"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Brand is the client for interacting with the Brand builders.
	Brand *BrandClient
	// Ingredient is the client for interacting with the Ingredient builders.
	Ingredient *IngredientClient
	// InventoryItem is the client for interacting with the InventoryItem builders.
	InventoryItem *InventoryItemClient
	// Kitchen is the client for interacting with the Kitchen builders.
	Kitchen *KitchenClient
	// KitchenResource is the client for interacting with the KitchenResource builders.
	KitchenResource *KitchenResourceClient
	// Menu is the client for interacting with the Menu builders.
	Menu *MenuClient
	// MenuItem is the client for interacting with the MenuItem builders.
	MenuItem *MenuItemClient
	// Order is the client for interacting with the Order builders.
	Order *OrderClient
	// OrderItem is the client for interacting with the OrderItem builders.
	OrderItem *OrderItemClient
	// ResourceAllocation is the client for interacting with the ResourceAllocation builders.
	ResourceAllocation *ResourceAllocationClient
	// Shift is the client for interacting with the Shift builders.
	Shift *ShiftClient
	// Staff is the client for interacting with the Staff builders.
	Staff *StaffClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Brand = NewBrandClient(c.config)
	c.Ingredient = NewIngredientClient(c.config)
	c.InventoryItem = NewInventoryItemClient(c.config)
	c.Kitchen = NewKitchenClient(c.config)
	c.KitchenResource = NewKitchenResourceClient(c.config)
	c.Menu = NewMenuClient(c.config)
	c.MenuItem = NewMenuItemClient(c.config)
	c.Order = NewOrderClient(c.config)
	c.OrderItem = NewOrderItemClient(c.config)
	c.ResourceAllocation = NewResourceAllocationClient(c.config)
	c.Shift = NewShiftClient(c.config)
	c.Staff = NewStaffClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Brand:              NewBrandClient(cfg),
		Ingredient:         NewIngredientClient(cfg),
		InventoryItem:      NewInventoryItemClient(cfg),
		Kitchen:            NewKitchenClient(cfg),
		KitchenResource:    NewKitchenResourceClient(cfg),
		Menu:               NewMenuClient(cfg),
		MenuItem:           NewMenuItemClient(cfg),
		Order:              NewOrderClient(cfg),
		OrderItem:          NewOrderItemClient(cfg),
		ResourceAllocation: NewResourceAllocationClient(cfg),
		Shift:              NewShiftClient(cfg),
		Staff:              NewStaffClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Brand:              NewBrandClient(cfg),
		Ingredient:         NewIngredientClient(cfg),
		InventoryItem:      NewInventoryItemClient(cfg),
		Kitchen:            NewKitchenClient(cfg),
		KitchenResource:    NewKitchenResourceClient(cfg),
		Menu:               NewMenuClient(cfg),
		MenuItem:           NewMenuItemClient(cfg),
		Order:              NewOrderClient(cfg),
		OrderItem:          NewOrderItemClient(cfg),
		ResourceAllocation: NewResourceAllocationClient(cfg),
		Shift:              NewShiftClient(cfg),
		Staff:              NewStaffClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Brand.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Brand, c.Ingredient, c.InventoryItem, c.Kitchen, c.KitchenResource, c.Menu,
		c.MenuItem, c.Order, c.OrderItem, c.ResourceAllocation, c.Shift, c.Staff,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Brand, c.Ingredient, c.InventoryItem, c.Kitchen, c.KitchenResource, c.Menu,
		c.MenuItem, c.Order, c.OrderItem, c.ResourceAllocation, c.Shift, c.Staff,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *BrandMutation:
		return c.Brand.mutate(ctx, m)
	case *IngredientMutation:
		return c.Ingredient.mutate(ctx, m)
	case *InventoryItemMutation:
		return c.InventoryItem.mutate(ctx, m)
	case *KitchenMutation:
		return c.Kitchen.mutate(ctx, m)
	case *KitchenResourceMutation:
		return c.KitchenResource.mutate(ctx, m)
	case *MenuMutation:
		return c.Menu.mutate(ctx, m)
	case *MenuItemMutation:
		return c.MenuItem.mutate(ctx, m)
	case *OrderMutation:
		return c.Order.mutate(ctx, m)
	case *OrderItemMutation:
		return c.OrderItem.mutate(ctx, m)
	case *ResourceAllocationMutation:
		return c.ResourceAllocation.mutate(ctx, m)
	case *ShiftMutation:
		return c.Shift.mutate(ctx, m)
	case *StaffMutation:
		return c.Staff.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// BrandClient is a client for the Brand schema.
type BrandClient struct {
	config
}

// NewBrandClient returns a client for the Brand from the given config.
func NewBrandClient(c config) *BrandClient {
	return &BrandClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `brand.Hooks(f(g(h())))`.
func (c *BrandClient) Use(hooks ...Hook) {
	c.hooks.Brand = append(c.hooks.Brand, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `brand.Intercept(f(g(h())))`.
func (c *BrandClient) Intercept(interceptors ...Interceptor) {
	c.inters.Brand = append(c.inters.Brand, interceptors...)
}

// Create returns a builder for creating a Brand entity.
func (c *BrandClient) Create() *BrandCreate {
	mutation := newBrandMutation(c.config, OpCreate)
	return &BrandCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Brand entities.
func (c *BrandClient) CreateBulk(builders ...*BrandCreate) *BrandCreateBulk {
	return &BrandCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BrandClient) MapCreateBulk(slice any, setFunc func(*BrandCreate, int)) *BrandCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BrandCreateBulk{err: fmt.Errorf("calling to BrandClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BrandCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BrandCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Brand.
func (c *BrandClient) Update() *BrandUpdate {
	mutation := newBrandMutation(c.config, OpUpdate)
	return &BrandUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BrandClient) UpdateOne(b *Brand) *BrandUpdateOne {
	mutation := newBrandMutation(c.config, OpUpdateOne, withBrand(b))
	return &BrandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BrandClient) UpdateOneID(id int) *BrandUpdateOne {
	mutation := newBrandMutation(c.config, OpUpdateOne, withBrandID(id))
	return &BrandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Brand.
func (c *BrandClient) Delete() *BrandDelete {
	mutation := newBrandMutation(c.config, OpDelete)
	return &BrandDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BrandClient) DeleteOne(b *Brand) *BrandDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BrandClient) DeleteOneID(id int) *BrandDeleteOne {
	builder := c.Delete().Where(brand.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BrandDeleteOne{builder}
}

// Query returns a query builder for Brand.
func (c *BrandClient) Query() *BrandQuery {
	return &BrandQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBrand},
		inters: c.Interceptors(),
	}
}

// Get returns a Brand entity by its id.
func (c *BrandClient) Get(ctx context.Context, id int) (*Brand, error) {
	return c.Query().Where(brand.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BrandClient) GetX(ctx context.Context, id int) *Brand {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryKitchen queries the kitchen edge of a Brand.
func (c *BrandClient) QueryKitchen(b *Brand) *KitchenQuery {
	query := (&KitchenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(brand.Table, brand.FieldID, id),
			sqlgraph.To(kitchen.Table, kitchen.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, brand.KitchenTable, brand.KitchenColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMenus queries the menus edge of a Brand.
func (c *BrandClient) QueryMenus(b *Brand) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(brand.Table, brand.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, brand.MenusTable, brand.MenusColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrders queries the orders edge of a Brand.
func (c *BrandClient) QueryOrders(b *Brand) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(brand.Table, brand.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, brand.OrdersTable, brand.OrdersColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BrandClient) Hooks() []Hook {
	return c.hooks.Brand
}

// Interceptors returns the client interceptors.
func (c *BrandClient) Interceptors() []Interceptor {
	return c.inters.Brand
}

func (c *BrandClient) mutate(ctx context.Context, m *BrandMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BrandCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BrandUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BrandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BrandDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Brand mutation op: %q", m.Op())
	}
}

// IngredientClient is a client for the Ingredient schema.
type IngredientClient struct {
	config
}

// NewIngredientClient returns a client for the Ingredient from the given config.
func NewIngredientClient(c config) *IngredientClient {
	return &IngredientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ingredient.Hooks(f(g(h())))`.
func (c *IngredientClient) Use(hooks ...Hook) {
	c.hooks.Ingredient = append(c.hooks.Ingredient, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ingredient.Intercept(f(g(h())))`.
func (c *IngredientClient) Intercept(interceptors ...Interceptor) {
	c.inters.Ingredient = append(c.inters.Ingredient, interceptors...)
}

// Create returns a builder for creating a Ingredient entity.
func (c *IngredientClient) Create() *IngredientCreate {
	mutation := newIngredientMutation(c.config, OpCreate)
	return &IngredientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Ingredient entities.
func (c *IngredientClient) CreateBulk(builders ...*IngredientCreate) *IngredientCreateBulk {
	return &IngredientCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IngredientClient) MapCreateBulk(slice any, setFunc func(*IngredientCreate, int)) *IngredientCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IngredientCreateBulk{err: fmt.Errorf("calling to IngredientClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IngredientCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IngredientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Ingredient.
func (c *IngredientClient) Update() *IngredientUpdate {
	mutation := newIngredientMutation(c.config, OpUpdate)
	return &IngredientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IngredientClient) UpdateOne(i *Ingredient) *IngredientUpdateOne {
	mutation := newIngredientMutation(c.config, OpUpdateOne, withIngredient(i))
	return &IngredientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IngredientClient) UpdateOneID(id int) *IngredientUpdateOne {
	mutation := newIngredientMutation(c.config, OpUpdateOne, withIngredientID(id))
	return &IngredientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Ingredient.
func (c *IngredientClient) Delete() *IngredientDelete {
	mutation := newIngredientMutation(c.config, OpDelete)
	return &IngredientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IngredientClient) DeleteOne(i *Ingredient) *IngredientDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IngredientClient) DeleteOneID(id int) *IngredientDeleteOne {
	builder := c.Delete().Where(ingredient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IngredientDeleteOne{builder}
}

// Query returns a query builder for Ingredient.
func (c *IngredientClient) Query() *IngredientQuery {
	return &IngredientQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIngredient},
		inters: c.Interceptors(),
	}
}

// Get returns a Ingredient entity by its id.
func (c *IngredientClient) Get(ctx context.Context, id int) (*Ingredient, error) {
	return c.Query().Where(ingredient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IngredientClient) GetX(ctx context.Context, id int) *Ingredient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMenuItems queries the menu_items edge of a Ingredient.
func (c *IngredientClient) QueryMenuItems(i *Ingredient) *MenuItemQuery {
	query := (&MenuItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ingredient.Table, ingredient.FieldID, id),
			sqlgraph.To(menuitem.Table, menuitem.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, ingredient.MenuItemsTable, ingredient.MenuItemsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInventoryItems queries the inventory_items edge of a Ingredient.
func (c *IngredientClient) QueryInventoryItems(i *Ingredient) *InventoryItemQuery {
	query := (&InventoryItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ingredient.Table, ingredient.FieldID, id),
			sqlgraph.To(inventoryitem.Table, inventoryitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, ingredient.InventoryItemsTable, ingredient.InventoryItemsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IngredientClient) Hooks() []Hook {
	return c.hooks.Ingredient
}

// Interceptors returns the client interceptors.
func (c *IngredientClient) Interceptors() []Interceptor {
	return c.inters.Ingredient
}

func (c *IngredientClient) mutate(ctx context.Context, m *IngredientMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IngredientCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IngredientUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IngredientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IngredientDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Ingredient mutation op: %q", m.Op())
	}
}

// InventoryItemClient is a client for the InventoryItem schema.
type InventoryItemClient struct {
	config
}

// NewInventoryItemClient returns a client for the InventoryItem from the given config.
func NewInventoryItemClient(c config) *InventoryItemClient {
	return &InventoryItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inventoryitem.Hooks(f(g(h())))`.
func (c *InventoryItemClient) Use(hooks ...Hook) {
	c.hooks.InventoryItem = append(c.hooks.InventoryItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `inventoryitem.Intercept(f(g(h())))`.
func (c *InventoryItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.InventoryItem = append(c.inters.InventoryItem, interceptors...)
}

// Create returns a builder for creating a InventoryItem entity.
func (c *InventoryItemClient) Create() *InventoryItemCreate {
	mutation := newInventoryItemMutation(c.config, OpCreate)
	return &InventoryItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InventoryItem entities.
func (c *InventoryItemClient) CreateBulk(builders ...*InventoryItemCreate) *InventoryItemCreateBulk {
	return &InventoryItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InventoryItemClient) MapCreateBulk(slice any, setFunc func(*InventoryItemCreate, int)) *InventoryItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InventoryItemCreateBulk{err: fmt.Errorf("calling to InventoryItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InventoryItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InventoryItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InventoryItem.
func (c *InventoryItemClient) Update() *InventoryItemUpdate {
	mutation := newInventoryItemMutation(c.config, OpUpdate)
	return &InventoryItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InventoryItemClient) UpdateOne(ii *InventoryItem) *InventoryItemUpdateOne {
	mutation := newInventoryItemMutation(c.config, OpUpdateOne, withInventoryItem(ii))
	return &InventoryItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InventoryItemClient) UpdateOneID(id int) *InventoryItemUpdateOne {
	mutation := newInventoryItemMutation(c.config, OpUpdateOne, withInventoryItemID(id))
	return &InventoryItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InventoryItem.
func (c *InventoryItemClient) Delete() *InventoryItemDelete {
	mutation := newInventoryItemMutation(c.config, OpDelete)
	return &InventoryItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InventoryItemClient) DeleteOne(ii *InventoryItem) *InventoryItemDeleteOne {
	return c.DeleteOneID(ii.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InventoryItemClient) DeleteOneID(id int) *InventoryItemDeleteOne {
	builder := c.Delete().Where(inventoryitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InventoryItemDeleteOne{builder}
}

// Query returns a query builder for InventoryItem.
func (c *InventoryItemClient) Query() *InventoryItemQuery {
	return &InventoryItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInventoryItem},
		inters: c.Interceptors(),
	}
}

// Get returns a InventoryItem entity by its id.
func (c *InventoryItemClient) Get(ctx context.Context, id int) (*InventoryItem, error) {
	return c.Query().Where(inventoryitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InventoryItemClient) GetX(ctx context.Context, id int) *InventoryItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryKitchen queries the kitchen edge of a InventoryItem.
func (c *InventoryItemClient) QueryKitchen(ii *InventoryItem) *KitchenQuery {
	query := (&KitchenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ii.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inventoryitem.Table, inventoryitem.FieldID, id),
			sqlgraph.To(kitchen.Table, kitchen.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inventoryitem.KitchenTable, inventoryitem.KitchenColumn),
		)
		fromV = sqlgraph.Neighbors(ii.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIngredient queries the ingredient edge of a InventoryItem.
func (c *InventoryItemClient) QueryIngredient(ii *InventoryItem) *IngredientQuery {
	query := (&IngredientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ii.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inventoryitem.Table, inventoryitem.FieldID, id),
			sqlgraph.To(ingredient.Table, ingredient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, inventoryitem.IngredientTable, inventoryitem.IngredientColumn),
		)
		fromV = sqlgraph.Neighbors(ii.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InventoryItemClient) Hooks() []Hook {
	return c.hooks.InventoryItem
}

// Interceptors returns the client interceptors.
func (c *InventoryItemClient) Interceptors() []Interceptor {
	return c.inters.InventoryItem
}

func (c *InventoryItemClient) mutate(ctx context.Context, m *InventoryItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InventoryItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InventoryItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InventoryItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InventoryItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InventoryItem mutation op: %q", m.Op())
	}
}

// KitchenClient is a client for the Kitchen schema.
type KitchenClient struct {
	config
}

// NewKitchenClient returns a client for the Kitchen from the given config.
func NewKitchenClient(c config) *KitchenClient {
	return &KitchenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `kitchen.Hooks(f(g(h())))`.
func (c *KitchenClient) Use(hooks ...Hook) {
	c.hooks.Kitchen = append(c.hooks.Kitchen, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `kitchen.Intercept(f(g(h())))`.
func (c *KitchenClient) Intercept(interceptors ...Interceptor) {
	c.inters.Kitchen = append(c.inters.Kitchen, interceptors...)
}

// Create returns a builder for creating a Kitchen entity.
func (c *KitchenClient) Create() *KitchenCreate {
	mutation := newKitchenMutation(c.config, OpCreate)
	return &KitchenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Kitchen entities.
func (c *KitchenClient) CreateBulk(builders ...*KitchenCreate) *KitchenCreateBulk {
	return &KitchenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *KitchenClient) MapCreateBulk(slice any, setFunc func(*KitchenCreate, int)) *KitchenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &KitchenCreateBulk{err: fmt.Errorf("calling to KitchenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*KitchenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &KitchenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Kitchen.
func (c *KitchenClient) Update() *KitchenUpdate {
	mutation := newKitchenMutation(c.config, OpUpdate)
	return &KitchenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *KitchenClient) UpdateOne(k *Kitchen) *KitchenUpdateOne {
	mutation := newKitchenMutation(c.config, OpUpdateOne, withKitchen(k))
	return &KitchenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *KitchenClient) UpdateOneID(id int) *KitchenUpdateOne {
	mutation := newKitchenMutation(c.config, OpUpdateOne, withKitchenID(id))
	return &KitchenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Kitchen.
func (c *KitchenClient) Delete() *KitchenDelete {
	mutation := newKitchenMutation(c.config, OpDelete)
	return &KitchenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *KitchenClient) DeleteOne(k *Kitchen) *KitchenDeleteOne {
	return c.DeleteOneID(k.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *KitchenClient) DeleteOneID(id int) *KitchenDeleteOne {
	builder := c.Delete().Where(kitchen.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &KitchenDeleteOne{builder}
}

// Query returns a query builder for Kitchen.
func (c *KitchenClient) Query() *KitchenQuery {
	return &KitchenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeKitchen},
		inters: c.Interceptors(),
	}
}

// Get returns a Kitchen entity by its id.
func (c *KitchenClient) Get(ctx context.Context, id int) (*Kitchen, error) {
	return c.Query().Where(kitchen.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *KitchenClient) GetX(ctx context.Context, id int) *Kitchen {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryResources queries the resources edge of a Kitchen.
func (c *KitchenClient) QueryResources(k *Kitchen) *KitchenResourceQuery {
	query := (&KitchenResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := k.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(kitchen.Table, kitchen.FieldID, id),
			sqlgraph.To(kitchenresource.Table, kitchenresource.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, kitchen.ResourcesTable, kitchen.ResourcesColumn),
		)
		fromV = sqlgraph.Neighbors(k.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStaff queries the staff edge of a Kitchen.
func (c *KitchenClient) QueryStaff(k *Kitchen) *StaffQuery {
	query := (&StaffClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := k.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(kitchen.Table, kitchen.FieldID, id),
			sqlgraph.To(staff.Table, staff.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, kitchen.StaffTable, kitchen.StaffColumn),
		)
		fromV = sqlgraph.Neighbors(k.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBrands queries the brands edge of a Kitchen.
func (c *KitchenClient) QueryBrands(k *Kitchen) *BrandQuery {
	query := (&BrandClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := k.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(kitchen.Table, kitchen.FieldID, id),
			sqlgraph.To(brand.Table, brand.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, kitchen.BrandsTable, kitchen.BrandsColumn),
		)
		fromV = sqlgraph.Neighbors(k.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInventory queries the inventory edge of a Kitchen.
func (c *KitchenClient) QueryInventory(k *Kitchen) *InventoryItemQuery {
	query := (&InventoryItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := k.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(kitchen.Table, kitchen.FieldID, id),
			sqlgraph.To(inventoryitem.Table, inventoryitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, kitchen.InventoryTable, kitchen.InventoryColumn),
		)
		fromV = sqlgraph.Neighbors(k.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *KitchenClient) Hooks() []Hook {
	return c.hooks.Kitchen
}

// Interceptors returns the client interceptors.
func (c *KitchenClient) Interceptors() []Interceptor {
	return c.inters.Kitchen
}

func (c *KitchenClient) mutate(ctx context.Context, m *KitchenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&KitchenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&KitchenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&KitchenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&KitchenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Kitchen mutation op: %q", m.Op())
	}
}

// KitchenResourceClient is a client for the KitchenResource schema.
type KitchenResourceClient struct {
	config
}

// NewKitchenResourceClient returns a client for the KitchenResource from the given config.
func NewKitchenResourceClient(c config) *KitchenResourceClient {
	return &KitchenResourceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `kitchenresource.Hooks(f(g(h())))`.
func (c *KitchenResourceClient) Use(hooks ...Hook) {
	c.hooks.KitchenResource = append(c.hooks.KitchenResource, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `kitchenresource.Intercept(f(g(h())))`.
func (c *KitchenResourceClient) Intercept(interceptors ...Interceptor) {
	c.inters.KitchenResource = append(c.inters.KitchenResource, interceptors...)
}

// Create returns a builder for creating a KitchenResource entity.
func (c *KitchenResourceClient) Create() *KitchenResourceCreate {
	mutation := newKitchenResourceMutation(c.config, OpCreate)
	return &KitchenResourceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of KitchenResource entities.
func (c *KitchenResourceClient) CreateBulk(builders ...*KitchenResourceCreate) *KitchenResourceCreateBulk {
	return &KitchenResourceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *KitchenResourceClient) MapCreateBulk(slice any, setFunc func(*KitchenResourceCreate, int)) *KitchenResourceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &KitchenResourceCreateBulk{err: fmt.Errorf("calling to KitchenResourceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*KitchenResourceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &KitchenResourceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for KitchenResource.
func (c *KitchenResourceClient) Update() *KitchenResourceUpdate {
	mutation := newKitchenResourceMutation(c.config, OpUpdate)
	return &KitchenResourceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *KitchenResourceClient) UpdateOne(kr *KitchenResource) *KitchenResourceUpdateOne {
	mutation := newKitchenResourceMutation(c.config, OpUpdateOne, withKitchenResource(kr))
	return &KitchenResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *KitchenResourceClient) UpdateOneID(id int) *KitchenResourceUpdateOne {
	mutation := newKitchenResourceMutation(c.config, OpUpdateOne, withKitchenResourceID(id))
	return &KitchenResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for KitchenResource.
func (c *KitchenResourceClient) Delete() *KitchenResourceDelete {
	mutation := newKitchenResourceMutation(c.config, OpDelete)
	return &KitchenResourceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *KitchenResourceClient) DeleteOne(kr *KitchenResource) *KitchenResourceDeleteOne {
	return c.DeleteOneID(kr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *KitchenResourceClient) DeleteOneID(id int) *KitchenResourceDeleteOne {
	builder := c.Delete().Where(kitchenresource.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &KitchenResourceDeleteOne{builder}
}

// Query returns a query builder for KitchenResource.
func (c *KitchenResourceClient) Query() *KitchenResourceQuery {
	return &KitchenResourceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeKitchenResource},
		inters: c.Interceptors(),
	}
}

// Get returns a KitchenResource entity by its id.
func (c *KitchenResourceClient) Get(ctx context.Context, id int) (*KitchenResource, error) {
	return c.Query().Where(kitchenresource.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *KitchenResourceClient) GetX(ctx context.Context, id int) *KitchenResource {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryKitchen queries the kitchen edge of a KitchenResource.
func (c *KitchenResourceClient) QueryKitchen(kr *KitchenResource) *KitchenQuery {
	query := (&KitchenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := kr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(kitchenresource.Table, kitchenresource.FieldID, id),
			sqlgraph.To(kitchen.Table, kitchen.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, kitchenresource.KitchenTable, kitchenresource.KitchenColumn),
		)
		fromV = sqlgraph.Neighbors(kr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAllocations queries the allocations edge of a KitchenResource.
func (c *KitchenResourceClient) QueryAllocations(kr *KitchenResource) *ResourceAllocationQuery {
	query := (&ResourceAllocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := kr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(kitchenresource.Table, kitchenresource.FieldID, id),
			sqlgraph.To(resourceallocation.Table, resourceallocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, kitchenresource.AllocationsTable, kitchenresource.AllocationsColumn),
		)
		fromV = sqlgraph.Neighbors(kr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *KitchenResourceClient) Hooks() []Hook {
	return c.hooks.KitchenResource
}

// Interceptors returns the client interceptors.
func (c *KitchenResourceClient) Interceptors() []Interceptor {
	return c.inters.KitchenResource
}

func (c *KitchenResourceClient) mutate(ctx context.Context, m *KitchenResourceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&KitchenResourceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&KitchenResourceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&KitchenResourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&KitchenResourceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown KitchenResource mutation op: %q", m.Op())
	}
}

// MenuClient is a client for the Menu schema.
type MenuClient struct {
	config
}

// NewMenuClient returns a client for the Menu from the given config.
func NewMenuClient(c config) *MenuClient {
	return &MenuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `menu.Hooks(f(g(h())))`.
func (c *MenuClient) Use(hooks ...Hook) {
	c.hooks.Menu = append(c.hooks.Menu, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `menu.Intercept(f(g(h())))`.
func (c *MenuClient) Intercept(interceptors ...Interceptor) {
	c.inters.Menu = append(c.inters.Menu, interceptors...)
}

// Create returns a builder for creating a Menu entity.
func (c *MenuClient) Create() *MenuCreate {
	mutation := newMenuMutation(c.config, OpCreate)
	return &MenuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Menu entities.
func (c *MenuClient) CreateBulk(builders ...*MenuCreate) *MenuCreateBulk {
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MenuClient) MapCreateBulk(slice any, setFunc func(*MenuCreate, int)) *MenuCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MenuCreateBulk{err: fmt.Errorf("calling to MenuClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MenuCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Menu.
func (c *MenuClient) Update() *MenuUpdate {
	mutation := newMenuMutation(c.config, OpUpdate)
	return &MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MenuClient) UpdateOne(m *Menu) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenu(m))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MenuClient) UpdateOneID(id int) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenuID(id))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Menu.
func (c *MenuClient) Delete() *MenuDelete {
	mutation := newMenuMutation(c.config, OpDelete)
	return &MenuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MenuClient) DeleteOne(m *Menu) *MenuDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MenuClient) DeleteOneID(id int) *MenuDeleteOne {
	builder := c.Delete().Where(menu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MenuDeleteOne{builder}
}

// Query returns a query builder for Menu.
func (c *MenuClient) Query() *MenuQuery {
	return &MenuQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMenu},
		inters: c.Interceptors(),
	}
}

// Get returns a Menu entity by its id.
func (c *MenuClient) Get(ctx context.Context, id int) (*Menu, error) {
	return c.Query().Where(menu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MenuClient) GetX(ctx context.Context, id int) *Menu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBrand queries the brand edge of a Menu.
func (c *MenuClient) QueryBrand(m *Menu) *BrandQuery {
	query := (&BrandClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(brand.Table, brand.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, menu.BrandTable, menu.BrandColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryItems queries the items edge of a Menu.
func (c *MenuClient) QueryItems(m *Menu) *MenuItemQuery {
	query := (&MenuItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menuitem.Table, menuitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, menu.ItemsTable, menu.ItemsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MenuClient) Hooks() []Hook {
	return c.hooks.Menu
}

// Interceptors returns the client interceptors.
func (c *MenuClient) Interceptors() []Interceptor {
	return c.inters.Menu
}

func (c *MenuClient) mutate(ctx context.Context, m *MenuMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MenuCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MenuDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Menu mutation op: %q", m.Op())
	}
}

// MenuItemClient is a client for the MenuItem schema.
type MenuItemClient struct {
	config
}

// NewMenuItemClient returns a client for the MenuItem from the given config.
func NewMenuItemClient(c config) *MenuItemClient {
	return &MenuItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `menuitem.Hooks(f(g(h())))`.
func (c *MenuItemClient) Use(hooks ...Hook) {
	c.hooks.MenuItem = append(c.hooks.MenuItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `menuitem.Intercept(f(g(h())))`.
func (c *MenuItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.MenuItem = append(c.inters.MenuItem, interceptors...)
}

// Create returns a builder for creating a MenuItem entity.
func (c *MenuItemClient) Create() *MenuItemCreate {
	mutation := newMenuItemMutation(c.config, OpCreate)
	return &MenuItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MenuItem entities.
func (c *MenuItemClient) CreateBulk(builders ...*MenuItemCreate) *MenuItemCreateBulk {
	return &MenuItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MenuItemClient) MapCreateBulk(slice any, setFunc func(*MenuItemCreate, int)) *MenuItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MenuItemCreateBulk{err: fmt.Errorf("calling to MenuItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MenuItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MenuItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MenuItem.
func (c *MenuItemClient) Update() *MenuItemUpdate {
	mutation := newMenuItemMutation(c.config, OpUpdate)
	return &MenuItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MenuItemClient) UpdateOne(mi *MenuItem) *MenuItemUpdateOne {
	mutation := newMenuItemMutation(c.config, OpUpdateOne, withMenuItem(mi))
	return &MenuItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MenuItemClient) UpdateOneID(id int) *MenuItemUpdateOne {
	mutation := newMenuItemMutation(c.config, OpUpdateOne, withMenuItemID(id))
	return &MenuItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MenuItem.
func (c *MenuItemClient) Delete() *MenuItemDelete {
	mutation := newMenuItemMutation(c.config, OpDelete)
	return &MenuItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MenuItemClient) DeleteOne(mi *MenuItem) *MenuItemDeleteOne {
	return c.DeleteOneID(mi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MenuItemClient) DeleteOneID(id int) *MenuItemDeleteOne {
	builder := c.Delete().Where(menuitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MenuItemDeleteOne{builder}
}

// Query returns a query builder for MenuItem.
func (c *MenuItemClient) Query() *MenuItemQuery {
	return &MenuItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMenuItem},
		inters: c.Interceptors(),
	}
}

// Get returns a MenuItem entity by its id.
func (c *MenuItemClient) Get(ctx context.Context, id int) (*MenuItem, error) {
	return c.Query().Where(menuitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MenuItemClient) GetX(ctx context.Context, id int) *MenuItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMenu queries the menu edge of a MenuItem.
func (c *MenuItemClient) QueryMenu(mi *MenuItem) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menuitem.Table, menuitem.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, menuitem.MenuTable, menuitem.MenuColumn),
		)
		fromV = sqlgraph.Neighbors(mi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIngredients queries the ingredients edge of a MenuItem.
func (c *MenuItemClient) QueryIngredients(mi *MenuItem) *IngredientQuery {
	query := (&IngredientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menuitem.Table, menuitem.FieldID, id),
			sqlgraph.To(ingredient.Table, ingredient.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, menuitem.IngredientsTable, menuitem.IngredientsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(mi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderItems queries the order_items edge of a MenuItem.
func (c *MenuItemClient) QueryOrderItems(mi *MenuItem) *OrderItemQuery {
	query := (&OrderItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menuitem.Table, menuitem.FieldID, id),
			sqlgraph.To(orderitem.Table, orderitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, menuitem.OrderItemsTable, menuitem.OrderItemsColumn),
		)
		fromV = sqlgraph.Neighbors(mi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MenuItemClient) Hooks() []Hook {
	return c.hooks.MenuItem
}

// Interceptors returns the client interceptors.
func (c *MenuItemClient) Interceptors() []Interceptor {
	return c.inters.MenuItem
}

func (c *MenuItemClient) mutate(ctx context.Context, m *MenuItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MenuItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MenuItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MenuItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MenuItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MenuItem mutation op: %q", m.Op())
	}
}

// OrderClient is a client for the Order schema.
type OrderClient struct {
	config
}

// NewOrderClient returns a client for the Order from the given config.
func NewOrderClient(c config) *OrderClient {
	return &OrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `order.Hooks(f(g(h())))`.
func (c *OrderClient) Use(hooks ...Hook) {
	c.hooks.Order = append(c.hooks.Order, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `order.Intercept(f(g(h())))`.
func (c *OrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Order = append(c.inters.Order, interceptors...)
}

// Create returns a builder for creating a Order entity.
func (c *OrderClient) Create() *OrderCreate {
	mutation := newOrderMutation(c.config, OpCreate)
	return &OrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Order entities.
func (c *OrderClient) CreateBulk(builders ...*OrderCreate) *OrderCreateBulk {
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderClient) MapCreateBulk(slice any, setFunc func(*OrderCreate, int)) *OrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderCreateBulk{err: fmt.Errorf("calling to OrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Order.
func (c *OrderClient) Update() *OrderUpdate {
	mutation := newOrderMutation(c.config, OpUpdate)
	return &OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderClient) UpdateOne(o *Order) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrder(o))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderClient) UpdateOneID(id int) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrderID(id))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Order.
func (c *OrderClient) Delete() *OrderDelete {
	mutation := newOrderMutation(c.config, OpDelete)
	return &OrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderClient) DeleteOne(o *Order) *OrderDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderClient) DeleteOneID(id int) *OrderDeleteOne {
	builder := c.Delete().Where(order.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderDeleteOne{builder}
}

// Query returns a query builder for Order.
func (c *OrderClient) Query() *OrderQuery {
	return &OrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a Order entity by its id.
func (c *OrderClient) Get(ctx context.Context, id int) (*Order, error) {
	return c.Query().Where(order.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderClient) GetX(ctx context.Context, id int) *Order {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBrand queries the brand edge of a Order.
func (c *OrderClient) QueryBrand(o *Order) *BrandQuery {
	query := (&BrandClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(brand.Table, brand.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, order.BrandTable, order.BrandColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryItems queries the items edge of a Order.
func (c *OrderClient) QueryItems(o *Order) *OrderItemQuery {
	query := (&OrderItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderitem.Table, orderitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.ItemsTable, order.ItemsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResourceAllocations queries the resource_allocations edge of a Order.
func (c *OrderClient) QueryResourceAllocations(o *Order) *ResourceAllocationQuery {
	query := (&ResourceAllocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(resourceallocation.Table, resourceallocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, order.ResourceAllocationsTable, order.ResourceAllocationsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderClient) Hooks() []Hook {
	return c.hooks.Order
}

// Interceptors returns the client interceptors.
func (c *OrderClient) Interceptors() []Interceptor {
	return c.inters.Order
}

func (c *OrderClient) mutate(ctx context.Context, m *OrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Order mutation op: %q", m.Op())
	}
}

// OrderItemClient is a client for the OrderItem schema.
type OrderItemClient struct {
	config
}

// NewOrderItemClient returns a client for the OrderItem from the given config.
func NewOrderItemClient(c config) *OrderItemClient {
	return &OrderItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderitem.Hooks(f(g(h())))`.
func (c *OrderItemClient) Use(hooks ...Hook) {
	c.hooks.OrderItem = append(c.hooks.OrderItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderitem.Intercept(f(g(h())))`.
func (c *OrderItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderItem = append(c.inters.OrderItem, interceptors...)
}

// Create returns a builder for creating a OrderItem entity.
func (c *OrderItemClient) Create() *OrderItemCreate {
	mutation := newOrderItemMutation(c.config, OpCreate)
	return &OrderItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderItem entities.
func (c *OrderItemClient) CreateBulk(builders ...*OrderItemCreate) *OrderItemCreateBulk {
	return &OrderItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderItemClient) MapCreateBulk(slice any, setFunc func(*OrderItemCreate, int)) *OrderItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderItemCreateBulk{err: fmt.Errorf("calling to OrderItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderItem.
func (c *OrderItemClient) Update() *OrderItemUpdate {
	mutation := newOrderItemMutation(c.config, OpUpdate)
	return &OrderItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderItemClient) UpdateOne(oi *OrderItem) *OrderItemUpdateOne {
	mutation := newOrderItemMutation(c.config, OpUpdateOne, withOrderItem(oi))
	return &OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderItemClient) UpdateOneID(id int) *OrderItemUpdateOne {
	mutation := newOrderItemMutation(c.config, OpUpdateOne, withOrderItemID(id))
	return &OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderItem.
func (c *OrderItemClient) Delete() *OrderItemDelete {
	mutation := newOrderItemMutation(c.config, OpDelete)
	return &OrderItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderItemClient) DeleteOne(oi *OrderItem) *OrderItemDeleteOne {
	return c.DeleteOneID(oi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderItemClient) DeleteOneID(id int) *OrderItemDeleteOne {
	builder := c.Delete().Where(orderitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderItemDeleteOne{builder}
}

// Query returns a query builder for OrderItem.
func (c *OrderItemClient) Query() *OrderItemQuery {
	return &OrderItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderItem},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderItem entity by its id.
func (c *OrderItemClient) Get(ctx context.Context, id int) (*OrderItem, error) {
	return c.Query().Where(orderitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderItemClient) GetX(ctx context.Context, id int) *OrderItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderItem.
func (c *OrderItemClient) QueryOrder(oi *OrderItem) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderitem.Table, orderitem.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderitem.OrderTable, orderitem.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMenuItem queries the menu_item edge of a OrderItem.
func (c *OrderItemClient) QueryMenuItem(oi *OrderItem) *MenuItemQuery {
	query := (&MenuItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderitem.Table, orderitem.FieldID, id),
			sqlgraph.To(menuitem.Table, menuitem.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, orderitem.MenuItemTable, orderitem.MenuItemColumn),
		)
		fromV = sqlgraph.Neighbors(oi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderItemClient) Hooks() []Hook {
	return c.hooks.OrderItem
}

// Interceptors returns the client interceptors.
func (c *OrderItemClient) Interceptors() []Interceptor {
	return c.inters.OrderItem
}

func (c *OrderItemClient) mutate(ctx context.Context, m *OrderItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderItem mutation op: %q", m.Op())
	}
}

// ResourceAllocationClient is a client for the ResourceAllocation schema.
type ResourceAllocationClient struct {
	config
}

// NewResourceAllocationClient returns a client for the ResourceAllocation from the given config.
func NewResourceAllocationClient(c config) *ResourceAllocationClient {
	return &ResourceAllocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resourceallocation.Hooks(f(g(h())))`.
func (c *ResourceAllocationClient) Use(hooks ...Hook) {
	c.hooks.ResourceAllocation = append(c.hooks.ResourceAllocation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resourceallocation.Intercept(f(g(h())))`.
func (c *ResourceAllocationClient) Intercept(interceptors ...Interceptor) {
	c.inters.ResourceAllocation = append(c.inters.ResourceAllocation, interceptors...)
}

// Create returns a builder for creating a ResourceAllocation entity.
func (c *ResourceAllocationClient) Create() *ResourceAllocationCreate {
	mutation := newResourceAllocationMutation(c.config, OpCreate)
	return &ResourceAllocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ResourceAllocation entities.
func (c *ResourceAllocationClient) CreateBulk(builders ...*ResourceAllocationCreate) *ResourceAllocationCreateBulk {
	return &ResourceAllocationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourceAllocationClient) MapCreateBulk(slice any, setFunc func(*ResourceAllocationCreate, int)) *ResourceAllocationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourceAllocationCreateBulk{err: fmt.Errorf("calling to ResourceAllocationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourceAllocationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourceAllocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ResourceAllocation.
func (c *ResourceAllocationClient) Update() *ResourceAllocationUpdate {
	mutation := newResourceAllocationMutation(c.config, OpUpdate)
	return &ResourceAllocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourceAllocationClient) UpdateOne(ra *ResourceAllocation) *ResourceAllocationUpdateOne {
	mutation := newResourceAllocationMutation(c.config, OpUpdateOne, withResourceAllocation(ra))
	return &ResourceAllocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourceAllocationClient) UpdateOneID(id int) *ResourceAllocationUpdateOne {
	mutation := newResourceAllocationMutation(c.config, OpUpdateOne, withResourceAllocationID(id))
	return &ResourceAllocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ResourceAllocation.
func (c *ResourceAllocationClient) Delete() *ResourceAllocationDelete {
	mutation := newResourceAllocationMutation(c.config, OpDelete)
	return &ResourceAllocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourceAllocationClient) DeleteOne(ra *ResourceAllocation) *ResourceAllocationDeleteOne {
	return c.DeleteOneID(ra.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourceAllocationClient) DeleteOneID(id int) *ResourceAllocationDeleteOne {
	builder := c.Delete().Where(resourceallocation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourceAllocationDeleteOne{builder}
}

// Query returns a query builder for ResourceAllocation.
func (c *ResourceAllocationClient) Query() *ResourceAllocationQuery {
	return &ResourceAllocationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResourceAllocation},
		inters: c.Interceptors(),
	}
}

// Get returns a ResourceAllocation entity by its id.
func (c *ResourceAllocationClient) Get(ctx context.Context, id int) (*ResourceAllocation, error) {
	return c.Query().Where(resourceallocation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourceAllocationClient) GetX(ctx context.Context, id int) *ResourceAllocation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryResource queries the resource edge of a ResourceAllocation.
func (c *ResourceAllocationClient) QueryResource(ra *ResourceAllocation) *KitchenResourceQuery {
	query := (&KitchenResourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ra.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourceallocation.Table, resourceallocation.FieldID, id),
			sqlgraph.To(kitchenresource.Table, kitchenresource.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resourceallocation.ResourceTable, resourceallocation.ResourceColumn),
		)
		fromV = sqlgraph.Neighbors(ra.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrder queries the order edge of a ResourceAllocation.
func (c *ResourceAllocationClient) QueryOrder(ra *ResourceAllocation) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ra.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourceallocation.Table, resourceallocation.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, resourceallocation.OrderTable, resourceallocation.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(ra.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryShift queries the shift edge of a ResourceAllocation.
func (c *ResourceAllocationClient) QueryShift(ra *ResourceAllocation) *ShiftQuery {
	query := (&ShiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ra.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(resourceallocation.Table, resourceallocation.FieldID, id),
			sqlgraph.To(shift.Table, shift.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, resourceallocation.ShiftTable, resourceallocation.ShiftColumn),
		)
		fromV = sqlgraph.Neighbors(ra.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResourceAllocationClient) Hooks() []Hook {
	return c.hooks.ResourceAllocation
}

// Interceptors returns the client interceptors.
func (c *ResourceAllocationClient) Interceptors() []Interceptor {
	return c.inters.ResourceAllocation
}

func (c *ResourceAllocationClient) mutate(ctx context.Context, m *ResourceAllocationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourceAllocationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourceAllocationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourceAllocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourceAllocationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ResourceAllocation mutation op: %q", m.Op())
	}
}

// ShiftClient is a client for the Shift schema.
type ShiftClient struct {
	config
}

// NewShiftClient returns a client for the Shift from the given config.
func NewShiftClient(c config) *ShiftClient {
	return &ShiftClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `shift.Hooks(f(g(h())))`.
func (c *ShiftClient) Use(hooks ...Hook) {
	c.hooks.Shift = append(c.hooks.Shift, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `shift.Intercept(f(g(h())))`.
func (c *ShiftClient) Intercept(interceptors ...Interceptor) {
	c.inters.Shift = append(c.inters.Shift, interceptors...)
}

// Create returns a builder for creating a Shift entity.
func (c *ShiftClient) Create() *ShiftCreate {
	mutation := newShiftMutation(c.config, OpCreate)
	return &ShiftCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Shift entities.
func (c *ShiftClient) CreateBulk(builders ...*ShiftCreate) *ShiftCreateBulk {
	return &ShiftCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ShiftClient) MapCreateBulk(slice any, setFunc func(*ShiftCreate, int)) *ShiftCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ShiftCreateBulk{err: fmt.Errorf("calling to ShiftClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ShiftCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ShiftCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Shift.
func (c *ShiftClient) Update() *ShiftUpdate {
	mutation := newShiftMutation(c.config, OpUpdate)
	return &ShiftUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ShiftClient) UpdateOne(s *Shift) *ShiftUpdateOne {
	mutation := newShiftMutation(c.config, OpUpdateOne, withShift(s))
	return &ShiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ShiftClient) UpdateOneID(id int) *ShiftUpdateOne {
	mutation := newShiftMutation(c.config, OpUpdateOne, withShiftID(id))
	return &ShiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Shift.
func (c *ShiftClient) Delete() *ShiftDelete {
	mutation := newShiftMutation(c.config, OpDelete)
	return &ShiftDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ShiftClient) DeleteOne(s *Shift) *ShiftDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ShiftClient) DeleteOneID(id int) *ShiftDeleteOne {
	builder := c.Delete().Where(shift.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ShiftDeleteOne{builder}
}

// Query returns a query builder for Shift.
func (c *ShiftClient) Query() *ShiftQuery {
	return &ShiftQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeShift},
		inters: c.Interceptors(),
	}
}

// Get returns a Shift entity by its id.
func (c *ShiftClient) Get(ctx context.Context, id int) (*Shift, error) {
	return c.Query().Where(shift.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ShiftClient) GetX(ctx context.Context, id int) *Shift {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStaff queries the staff edge of a Shift.
func (c *ShiftClient) QueryStaff(s *Shift) *StaffQuery {
	query := (&StaffClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(shift.Table, shift.FieldID, id),
			sqlgraph.To(staff.Table, staff.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, shift.StaffTable, shift.StaffColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAllocations queries the allocations edge of a Shift.
func (c *ShiftClient) QueryAllocations(s *Shift) *ResourceAllocationQuery {
	query := (&ResourceAllocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(shift.Table, shift.FieldID, id),
			sqlgraph.To(resourceallocation.Table, resourceallocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, shift.AllocationsTable, shift.AllocationsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ShiftClient) Hooks() []Hook {
	return c.hooks.Shift
}

// Interceptors returns the client interceptors.
func (c *ShiftClient) Interceptors() []Interceptor {
	return c.inters.Shift
}

func (c *ShiftClient) mutate(ctx context.Context, m *ShiftMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ShiftCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ShiftUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ShiftUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ShiftDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Shift mutation op: %q", m.Op())
	}
}

// StaffClient is a client for the Staff schema.
type StaffClient struct {
	config
}

// NewStaffClient returns a client for the Staff from the given config.
func NewStaffClient(c config) *StaffClient {
	return &StaffClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `staff.Hooks(f(g(h())))`.
func (c *StaffClient) Use(hooks ...Hook) {
	c.hooks.Staff = append(c.hooks.Staff, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `staff.Intercept(f(g(h())))`.
func (c *StaffClient) Intercept(interceptors ...Interceptor) {
	c.inters.Staff = append(c.inters.Staff, interceptors...)
}

// Create returns a builder for creating a Staff entity.
func (c *StaffClient) Create() *StaffCreate {
	mutation := newStaffMutation(c.config, OpCreate)
	return &StaffCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Staff entities.
func (c *StaffClient) CreateBulk(builders ...*StaffCreate) *StaffCreateBulk {
	return &StaffCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StaffClient) MapCreateBulk(slice any, setFunc func(*StaffCreate, int)) *StaffCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StaffCreateBulk{err: fmt.Errorf("calling to StaffClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StaffCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StaffCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Staff.
func (c *StaffClient) Update() *StaffUpdate {
	mutation := newStaffMutation(c.config, OpUpdate)
	return &StaffUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StaffClient) UpdateOne(s *Staff) *StaffUpdateOne {
	mutation := newStaffMutation(c.config, OpUpdateOne, withStaff(s))
	return &StaffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StaffClient) UpdateOneID(id int) *StaffUpdateOne {
	mutation := newStaffMutation(c.config, OpUpdateOne, withStaffID(id))
	return &StaffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Staff.
func (c *StaffClient) Delete() *StaffDelete {
	mutation := newStaffMutation(c.config, OpDelete)
	return &StaffDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StaffClient) DeleteOne(s *Staff) *StaffDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StaffClient) DeleteOneID(id int) *StaffDeleteOne {
	builder := c.Delete().Where(staff.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StaffDeleteOne{builder}
}

// Query returns a query builder for Staff.
func (c *StaffClient) Query() *StaffQuery {
	return &StaffQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStaff},
		inters: c.Interceptors(),
	}
}

// Get returns a Staff entity by its id.
func (c *StaffClient) Get(ctx context.Context, id int) (*Staff, error) {
	return c.Query().Where(staff.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StaffClient) GetX(ctx context.Context, id int) *Staff {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryKitchen queries the kitchen edge of a Staff.
func (c *StaffClient) QueryKitchen(s *Staff) *KitchenQuery {
	query := (&KitchenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staff.Table, staff.FieldID, id),
			sqlgraph.To(kitchen.Table, kitchen.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, staff.KitchenTable, staff.KitchenColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryShifts queries the shifts edge of a Staff.
func (c *StaffClient) QueryShifts(s *Staff) *ShiftQuery {
	query := (&ShiftClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staff.Table, staff.FieldID, id),
			sqlgraph.To(shift.Table, shift.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, staff.ShiftsTable, staff.ShiftsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StaffClient) Hooks() []Hook {
	return c.hooks.Staff
}

// Interceptors returns the client interceptors.
func (c *StaffClient) Interceptors() []Interceptor {
	return c.inters.Staff
}

func (c *StaffClient) mutate(ctx context.Context, m *StaffMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StaffCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StaffUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StaffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StaffDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Staff mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Brand, Ingredient, InventoryItem, Kitchen, KitchenResource, Menu, MenuItem,
		Order, OrderItem, ResourceAllocation, Shift, Staff []ent.Hook
	}
	inters struct {
		Brand, Ingredient, InventoryItem, Kitchen, KitchenResource, Menu, MenuItem,
		Order, OrderItem, ResourceAllocation, Shift, Staff []ent.Interceptor
	}
)
